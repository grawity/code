#!/usr/bin/env python3
# cputemp -- visually monitor CPU temperature
import argparse
from collections import defaultdict
import enum
from glob import glob
import os
import signal
import sys
import time

class RollingAverage():
    def __init__(self, depth=3):
        assert depth > 0
        self._depth = depth
        self._hist = [0] * depth
        self._roll = 0
        self._count = 0

    def add(self, value):
        if self._count == 0:
            self._hist = [value] * self._depth
            self._roll = value * self._depth
        else:
            self._roll -= self._hist[self._count % self._depth]
            self._hist[self._count % self._depth] = value
            self._roll += value
        self._count += 1

    def get(self):
        return self._roll / self._depth

class Color(enum.IntEnum):
    Red = 1
    Green = 2
    Yellow = 3
    Blue = 4

def fround(val):
    # Round 0.5 up (Python rounds 0.5 down)
    return round(val + 0.1)

def get_load_averages():
    with open("/proc/loadavg", "r") as fh:
        buf = fh.read().strip().split()
    return [float(x) for x in buf[:3]]

def put(s):
    print(s, end="", flush=True)

def set_title(text):
    print("\033]0;%s\033\\" % text, end="", flush=True)

def set_wname(text):
    if os.environ["TERM"].startswith("tmux"):
        print("\033k%s\033\\" % text, end="", flush=True)

def get_loadavg():
    with open("/proc/loadavg", "r") as fh:
        a, b, c, *_ = fh.read().split()
    return float(a), float(b), float(c)

def put_bar(color, width, char):
    bar = ""
    if width <= 0:
        return
    if color:
        bar += "\033[38;5;%dm" % color
    if len(char) == 2:
        bar += char[0] * (width-1) + char[1]
    else:
        bar += char[0] * width
    if color:
        bar += "\033[m"
    print(bar, end="")

def draw_bar(ts, is_current, width, temp, load):
    global ravg
    color = 8 if is_current else 0
    avg = ravg.get()
    if avg > 79:
        color += Color.Red
    elif avg >= 63:
        color += Color.Yellow
    elif avg > 43:
        color += Color.Green
    else:
        color += Color.Blue

    width = int(temp) - 20
    print(time.strftime("%T ", time.localtime(ts)), end="")
    if is_current:
        char = "█"
    else:
	    char = "-║"
    put_bar(color, width, char)
    print(f" {temp:3d}°C", end="")
    if load:
        print(f"  \033[2m{load:.2f}\033[m", end="")
    print(flush=True)

def rsuffix(string, old, new):
    if string.endswith(old):
        return string[:-len(old)] + str(new)
    return string

def find_hwmon_by_name(name):
    for dev in glob("/sys/class/hwmon/hwmon*"):
        if os.path.exists("%s/name" % dev):
            with open("%s/name" % dev, "r") as fh:
                dev_name = fh.read().strip()
            if dev_name == "coretemp":
                return dev
    raise RuntimeError("no %r hwmon device found" % name)

def find_sensor():
    dev = find_hwmon_by_name("coretemp")

    subdev = None
    subdev_pkg = None
    subdev_cr0 = None
    for path_label in glob("%s/temp*_label" % dev):
        path_input = rsuffix(path_label, "_label", "_input")
        with open(path_label, "r") as fh:
            label = fh.read().strip()
        if label == "Package id 0":
            subdev_pkg = path_input
        elif label == "Core 0":
            subdev_cr0 = path_input
    if subdev_pkg:
        subdev = subdev_pkg
    elif subdev_cr0:
        subdev = subdev_cr0
    else:
        raise RuntimeError("no 'coretemp/Core 0' hwmon sensor found")

    with open("%s/name" % dev, "r") as fh:
        dev_name = fh.read().strip()
    with open(rsuffix(subdev, "_input", "_label"), "r") as fh:
        subdev_name = fh.read().strip()
    print("Using sensor %r (%s:%s)" % (subdev, dev_name, subdev_name), file=sys.stderr)

    return subdev

def print_histogram(data, *, width=5, unit="", barwidth=50):
    def buckets(data, width):
        res = defaultdict(int)
        for k, v in data.items():
            lo = k - (k % width)
            hi = lo + width
            res[lo, hi] += v
        return res

    total = sum(data.values())
    grouped = buckets(data, width)
    for (lo, hi), v in sorted(grouped.items()):
        percentage = 100 * v / total
        width = barwidth * percentage / 100
        label = "%4s, %-4s" % ("[%s" % lo, "%s)" % hi)
        suffix = "(%d%s, %d%%)" % (v, unit, percentage)
        print("%10s | %s  %s" % (label, "=" * round(width), suffix))
    print("%10s +-%s" % ("", "-" * barwidth))

class MeterBar:
    def __init__(self, interval):
        # Last values for redraw/overdraw
        self.last_ts = 0
        self.last_temp = 0
        self.last_load = 0

        # Statistics
        self.interval = interval
        self.max_temp = 0
        self.time_temps = defaultdict(int)

    def _draw_bar(self, is_current, time, temp, load):
        width = temp - 20
        draw_bar(time, is_current, width, temp, load)

    def overdraw_bar(self):
        put("\033[A") # One line up
        put("\r\033[K") # Reset position after signal
        self._draw_bar(False, self.last_ts, self.last_temp, self.last_load)

    def update(self, ts, temp, load):
        temp = fround(temp)

        self._draw_bar(True, ts, temp, load)
        set_title(f"{hostname}: {temp}°C (load {load:.2f})")
        set_wname(f"{temp}°C")

        # Store values for overdraw
        self.last_ts = ts
        self.last_temp = temp
        self.last_load = load

        # Update stats
        self.max_temp = max(self.max_temp, temp)
        self.time_temps[fround(temp)] += args.interval

    def print_stats(self, from_signal=False):
        if from_signal:
            self.overdraw_bar()

        print()
        print("Statistics:")
        print_histogram(self.time_temps, unit="s")
        for _min in [60, 70, 80, 90]:
            temp_secs = sum([_time
                             for (_temp, _time) in self.time_temps.items()
                             if _temp >= _min])
            if temp_secs:
                print(f"Spent {temp_secs}s at or above {_min}°C")

        max_temp = self.max_temp
        max_temp_secs = self.time_temps[max_temp]
        print(f"Maximum temperature: {max_temp}°C (for {max_temp_secs}s)")

        if from_signal:
            print()
            self._draw_bar(True, self.last_ts, self.last_temp, self.last_load)

parser = argparse.ArgumentParser()
parser.add_argument("-r", "--raw", action="store_true",
                    help="output only temperature value")
parser.add_argument("-n", "--interval", metavar="SECS", type=int, default=1,
                    help="specify update interval")
args = parser.parse_args()

hostname = os.uname().nodename
subdev = find_sensor()

if args.raw:
    try:
        while True:
            with open(subdev, "r") as fh:
                temp = int(fh.read())
                temp = temp / 1000
            print(f"{temp:.1f}", flush=True)
            time.sleep(args.interval)
    except KeyboardInterrupt:
        exit(0)
else:
    try:
        ravg = RollingAverage(3)
        m = MeterBar(interval=args.interval)
        signal.signal(signal.SIGQUIT, lambda s, f: m.print_stats(True))
        while True:
            if m.last_temp:
                time.sleep(args.interval)
                m.overdraw_bar()
            ts = time.time()
            with open(subdev, "r") as fh:
                temp = int(fh.read())
                temp = fround(temp / 1000)
                ravg.add(temp)
            load = get_load_averages()[0]
            m.update(ts, temp, load)
    except RuntimeError as e:
        exit(f"error: {e}")
    except KeyboardInterrupt:
        m.print_stats()
        exit(0)
