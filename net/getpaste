#!/usr/bin/env perl
# getpaste - retrieves raw text from pastebins
#
# (c) 2010-2015 Mantas MikulÄ—nas <grawity@gmail.com>
# Released under the MIT license (see dist/LICENSE.mit)
use warnings;
use strict;
no locale;
use Getopt::Long qw(:config bundling no_ignore_case);
use JSON;
use LWP::UserAgent;
use MIME::Base64;

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($arg0, $warnings, $errors);
		$::arg0 = (split m!/!, $0)[-1];
		$::debug = !!$ENV{DEBUG};
		sub _debug { warn "debug: @_\n" if $::debug; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

sub _prompt {
	my $msg = shift;
	print STDERR "\e[1m$msg\e[m "; $|++;
	chomp(my $resp = <STDIN>);
	$resp;
}

my $UA = LWP::UserAgent->new;

sub get {
	my $url = shift;

	_debug("fetching '$url'");
	my $resp = $UA->get($url);

	if ($resp->is_success) {
		_debug("fetch complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("fetch failed: '".$resp->status_line."'");
		return undef;
	}
}

sub getprint {
	my ($url) = @_;

	my $data = get($url);
	if (defined $data) {
		print $data;
	}
}

sub post {
	my ($url, %form) = @_;

	_debug("posting to '$url'");
	my $resp = $UA->post($url, \%form);

	if ($resp->is_success) {
		_debug("post complete: '".$resp->status_line."'");
		return $resp->decoded_content // $resp->content;
	} else {
		_err("post failed: '".$resp->status_line."'");
		return undef;
	}
}

sub decode_sour_base64 {
	my ($str) = @_;

	$str =~ y!_-!/+!;
	return decode_base64($str);
}

sub decode_html {
	my $str = shift;

	$str =~ s/&lt;/</g;
	$str =~ s/&gt;/>/g;
	$str =~ s/&quot;/"/g;
	$str =~ s/&amp;/\&/g;
	return $str;
}

sub try_decode_json {
	my $data = shift;

	return ref $data ? $data : decode_json($data);
}

sub EVP_BytesToKey {
	eval {
		require Crypt::Digest::MD5;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::MD5->import("md5");

	my ($salt, $passphrase, $ks, $ivs) = @_;

	my $hash = "";
	my $buf = "";

	while (length($buf) < $ks + $ivs) {
		$hash = md5($hash, $passphrase, $salt);
		$buf .= $hash;
	}

	my $key = substr($buf, 0, $ks);
	my $iv = substr($buf, $ks, $ivs);

	return ($key, $iv);
}

sub decrypt_sjcl {
	eval {
		require Crypt::AuthEnc::CCM;
		require Crypt::KeyDerivation;
	} or _die("missing Perl package 'CryptX'");

	Crypt::AuthEnc::CCM->import(":all");
	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: JSON
	# key derivation: PBKDF2-SHA256
	# encryption: AES128-CCM

	my ($frag, $json) = @_;

	my $data = try_decode_json($json);

	if (($data->{v} //= "1") != 1) {
		_die("unsupported SJCL blob version ".$data->{v});
	}
	if (($data->{cipher} //= "aes") ne "aes") {
		_die("unsupported cipher ".$data->{cipher});
	}
	if (($data->{mode} //= "ccm") ne "ccm") {
		_die("unsupported mode ".$data->{mode});
	}

	my $salt = decode_base64($data->{salt});
	my $ct   = decode_base64($data->{ct});
	my $iv   = decode_base64($data->{iv});
	my $iter = int($data->{iter} || 1000),
	my $ks   = int($data->{ks} || 128) / 8; # key size
	my $ts   = int($data->{ts} || 64) / 8; # tag size
	my $hdr  = decode_base64($data->{adata} // "");

	my $key  = pbkdf2($frag, $salt, $iter, "SHA256", $ks);
	my $tag  = substr($ct, -$ts, $ts, "");

	return ccm_decrypt_verify("AES", $key, $iv, $hdr, $ct, $tag)
	       // _die("decryption failed");
}

sub decrypt_ezcrypt {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::KeyDerivation;
		require Crypt::Mode::OFB;
	} or _die("missing Perl package 'CryptX'");

	Crypt::KeyDerivation->import("pbkdf2");

	# serialization: raw [salt + data]
	# key derivation: PBKDF2-SHA1
	# encryption: AES-256-OFB

	my ($frag, $data) = @_;

	my $ks   = Crypt::Cipher::AES->keysize;
	my $bs   = Crypt::Cipher::AES->blocksize;

	my $salt = substr($data, 0, $bs, "");
	my $iter = 1; # LOL
	my $key  = pbkdf2($frag, $salt, $iter, "SHA1", $ks);
	my $iv   = $salt;

	return Crypt::Mode::OFB->new("AES")->decrypt($data, $key, $iv);
}

sub decrypt_sour {
	eval {
		require Crypt::Cipher::AES;
		require Crypt::Mode::CBC;
	} or _die("missing Perl package 'CryptX'");

	# serialization: raw [magic + salt + data]
	# key derivation: EVP_BytesToKey (MD5)
	# encryption: AES-256-CBC

	my ($frag, $data) = @_;

	my $ks    = Crypt::Cipher::AES->keysize;
	my $bs    = Crypt::Cipher::AES->blocksize;

	my $magic = substr($data, 0, 8, "");
	my $salt  = substr($data, 0, 8, "");

	if ($magic ne "Salted__") {
		_die("bad magic value in encrypted data");
	}
	my ($key, $iv) = EVP_BytesToKey($salt, $frag, $ks, $bs);

	return Crypt::Mode::CBC->new("AES")->decrypt($data, $key, $iv);
}

sub decompress_lzw {
	eval {
		require Compress::LZW;
	} or _die("missing Perl package 'Compress::LZW'");

	my ($buf) = @_;

	return Compress::LZW->decompress($buf);
}

sub decompress_deflate {
	eval {
		require Compress::Raw::Zlib;
	} or _die("missing Perl package 'Compress::Raw::Zlib'");

	my ($buf, %opt) = @_;

	my $wbits;
	my $stream;
	my $status;
	my $outbuf;

	if ($opt{is_gzip}) {
		$wbits = Compress::Raw::Zlib->WANT_GZIP;
	} else {
		$wbits = -Compress::Raw::Zlib->MAX_WBITS;
	}

	($stream, $status) = Compress::Raw::Zlib::Inflate->new(-WindowBits => $wbits);
	if ($status != Compress::Raw::Zlib->Z_OK) {
		_die("inflateInit failed: $status");
	}

	$status = $stream->inflate($buf, $outbuf);
	if ($status != Compress::Raw::Zlib->Z_OK &&
	    $status != Compress::Raw::Zlib->Z_STREAM_END) {
		_die("inflate failed: $status (".$stream->msg.")");
	}

	return $outbuf;
}

sub decompress_gzip {
	my ($buf) = @_;

	return decompress_deflate($buf, is_gzip => 1);
}

sub dl_0bin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url);
	$body =~ m{<code>\n\s*(\{.+\})\n\s*</code>} || return;

	my $data = decode_html($1);
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	#$data = decompress_lzw($data);
	return $data;
}

sub dl_ezcrypt {
	eval {
		require Crypt::Digest::SHA1;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::SHA1->import("sha1_hex");

	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $password;
	my $body;
	my $data;

	$body = get($url);

	while ($body =~ /<div id="askpassword">/) {
		if (-t 0) {
			_debug("paste is password-protected");
			$password = _prompt("password?");
		} else {
			_die("paste is password-protected");
		}
		$body = post($url, p => sha1_hex($password)) || return;
	}

	if ($body =~ /DOCTYPE/) {
		$body =~ m{<input .+ id="data" value="(.+)" />}s || return;
		$data = $1;
	}
	elsif ($body =~ /^\{/) {
		$data = decode_json($body);
		$data = $data->{data};
	}

	$data = decode_base64($data);
	$data = decrypt_ezcrypt($frag, $data);
	return $data;
}

sub dl_zerobin {
	my ($url, $frag) = @_;

	if (!length $frag) {
		_die("cannot decrypt without key in URL fragment");
	}

	my $body = get($url) // return;
	$body =~ m{<div id="cipherdata" style="display:none;">(.+)</div>} || return;

	my $data = decode_html($1);
	$data = decode_json($data)->[0]->{data};
	$data = decrypt_sjcl($frag, $data);
	$data = decode_base64($data);
	$data = decompress_deflate($data);
	return $data;
}

sub dl_sour {
	eval {
		require Crypt::Digest::RIPEMD160;
	} or _die("missing Perl package 'CryptX'");

	Crypt::Digest::RIPEMD160->import("ripemd160");

	my ($url, $frag) = @_;

	my $body = get($url) // return;
	my @body = split(/\n\n/, $body);

	my %headers = map {/^(\S+):\s*(.*)$/} split(/\n/, $body[0]);
	_debug("found header: $_='$headers{$_}'") for sort keys %headers;
	if ($headers{chk}) {
		my $k = decode_sour_base64($frag);
		my $c = decode_sour_base64($headers{chk});
		if (ripemd160($k) ne $c) {
			_die("decryption failed (incorrect key)");
		}
	}

	my $data = decode_base64($body[1]);
	$data = decrypt_sour($frag, $data);
	if (($headers{zip} // "") eq "True") {
		$data = decompress_gzip($data);
	}
	return $data;
}

my @sites = (
	{
		host => "sprunge.us",
	},
	{
		host => "codepad.org",
		path => qr!^(/\w+)!,
		to_path => "#1/raw.txt",
	},
	{
		host => "dpaste.com",
		path => qr!^(?:/hold)?(/\d+)!,
		to_path => "#1/plain/",
	},
	{
		host => ["dpaste.org", "dpaste.de"],
		path => qr!^(/\w+)!,
		to_path => "#1/raw/",
	},
	{
		host => "fpaste.org",
		path => qr!^(/\w+(?:/\d+)?)!,
		to_path => "#1/raw/",
	},
	{
		host => "ghostbin.com",
		path => qr!^(/paste/\w+)!,
		to_path => "#1/raw",
	},
	{
		host => "gist.github.com",
		to_path => "#0.txt",
	},
	{
		host => qr/^(www\.)?irccloud\.com$/,
		path => qr!^(/pastebin/\w+)!,
		to_path => "#1.raw",
	},
	{
		host => "pastebin.com",
		path => qr!^(?:/index)?/(\w+)!,
		to_path => "/download.php?i=#1",
	},
	{
		host => "pastie.org",
		path => qr!^/(\d+)!,
		to_path => "/pastes/#1/download",
	},
	# cryptobins
	{
		host => "0bin.net",
		parser => \&dl_0bin,
	},
	{
		host => "ezcrypt.it",
		parser => \&dl_ezcrypt,
	},
	{
		host => "sour.is",
		path => "/p/",
		fragment => qr{^/(.+)!(.+)},
		to_path => "/p.store/#{fragment.1}",
		to_fragment => "#{fragment.2}",
		parser => \&dl_sour,
	},
);

sub smart_match {
	my ($str, $pattern) = @_;

	if (ref($pattern) eq "ARRAY") {
		for (@$pattern) {
			my @res = smart_match($str, $_);
			return @res if @res;
		}
	}
	elsif (ref($pattern) eq "Regexp" && $str =~ $pattern) {
		# If $pattern has no capture groups, =~ will return an
		# (1,) in list context since it needs a trueish value.
		# This piece linenoise works consistently in all cases.
		return map {substr($str, $-[$_], $+[$_]-$-[$_])} 0..$#-;
	}
	elsif (ref($pattern) eq "" && $str eq $pattern) {
		return $str;
	}
	return;
}

my $EXPN_RE = qr/#(#|\d|\{\w+.\d+\})/;

sub expn {
	my ($str, $data, $def) = @_;

	for ($str) {
		if ($_ eq "#") {
			return $_;
		} elsif ($def && /^(\d+)$/) {
			return $data->{$def}->[$1] // "";
		} elsif (/^\{(\w+).(\d+)\}$/) {
			return $data->{$1}->[$2] // "";
		} else {
			_err("unknown expansion '#$_'");
			return "\x{1F612}";
		}
	}
};

my $URL_RE = qr{
		(?:    (?<scheme> [^:\/?\#]+) : )?
		(?: // (?<host> [^/?#]*)        )?
		       (?<path> [^?#]*)
		(?: \? (?<query> [^#]*)         )?
		(?: \# (?<fragment> .*)         )?
	}x;

sub parse_url {
	my ($url) = @_;

	if ($url =~ $URL_RE) { return %+; }
}

sub unparse_url {
	my (%url) = @_;

	my $url = $url{scheme}."://".$url{host};
	$url .= $url{path}         if defined($url{path});
	$url .= "?".$url{query}    if defined($url{query});
	$url .= "#".$url{fragment} if defined($url{fragment});
	return $url;
}

sub translate_paste_url {
	my ($url) = @_;

	my @fields = qw(scheme host path query fragment);

	my %url = parse_url($url);

	unless (%url && defined($url{host}) && defined($url{path})) {
		_die("bad URL: $url");
	}

	_debug("scheme='".($url{scheme}//"")."'".
		", host='".($url{host}//"")."'".
		", path='".($url{path}//"")."'".
		", query='".($url{query}//"")."'".
		", frag='".($url{fragment}//"")."'");

SITE:	for my $site (@sites) {
		use Data::Dumper;

		my %match;
		for (@fields) {
			my $pat = $site->{"$_"} or next;
			my @res = smart_match($url{$_}, $pat) or next SITE;
			$match{$_} = \@res;
		}
		next if !%match;

		print Dumper($site);
		print Dumper(\%match);

		for (@fields) {
			my $fmt = $site->{"to_$_"} or next;
			$fmt =~ s/$EXPN_RE/expn($1, \%match, "path")/ge;
			$url{$_} = $fmt;
		}

		print Dumper(\%url);

		my $url = unparse_url(%url);
		print "=> $url\n";

		my $func = $site->{"parser"};
		if ($func) {
			return ($url, $func, $url{fragment});
		} else {
			return ($url);
		}
	}

	# old matching

	my ($scheme, $host, $path, $query, $frag) = @url{@fields};

	$path =~ s|^/||;
	$query //= "";

	if ($host =~ /^sprunge\.us$/)
		{ return $url }

	elsif ($host =~ /^(?:[\w-]+\.)?pastebin\.ca$/ and $path =~ m!^(?:raw/)?(\d+)!)
		{ return "$scheme://$host/raw/$1" }

	elsif ($host =~ /(?:dark-)?code\.bulix\.org$/ and $path =~ m!^(\w+-\d+)!)
		{ return "$scheme://$host/$1?raw" }

	elsif ($host =~ /^paste\.fedoraproject\.org$/)
		{ return "$scheme://$host/$path/raw" }

	elsif ($host =~ /^pastebin\.de$/ and $path =~ m!^(\d+)!)
		{ return "$scheme://$host/download/?id=$1" }

	elsif ($host =~ /^privatepaste\.com$/ and $path =~ m!^(\w+)!)
		{ return "$scheme://$host/download/$1" }

	elsif ($host =~ /^hastebin\.com$/ and $path =~ m!^(\w+)!)
		{ return "$scheme://hastebin.com/raw/$1" }

	elsif ($host =~ /^www\.dropbox\.com$/)
		{ "$scheme://dl.dropboxusercontent.com/$path" }

	# cryptobins

	elsif ($url =~ m{^zerobin\+(https?://.+)$})
		{ $1, \&dl_zerobin, $frag }

	elsif ($query =~ /^[0-9a-f]{16}$/ && $frag =~ m{^[0-9A-Za-z+/]{43}=$})
		{ _debug("probably a ZeroBin site based on query & fragment");
		  $url, \&dl_zerobin, $frag }

	# final

	else
		{ return undef }
}

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-u] <url>",
	"",                       #
	"  -u, --show-url         Output only the URL of raw document",
}

# Option parsing

my $insecure = 0;
my $showurl = 0;

GetOptions(
	"help"		=> sub { usage(); exit; },
	"insecure"	=> \$insecure,
	"u|show-url"	=> \$showurl,
) or exit 2;

if (!@ARGV) {
	_die("missing URL", 2);
}

if ($insecure) {
	$UA->ssl_opts(verify_hostname => 0);
}

unless ($ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
	$UA->ssl_opts(SSL_ca_file => "/etc/ssl/certs/ca-certificates.crt");
}

# Main code

for my $url (@ARGV) {
	my ($raw, $handler, @hargs) = translate_paste_url($url);
	if (!defined $raw && !defined $handler) {
		_err("unknown pastebin: $url");
	} elsif ($showurl) {
		if ($handler) {
			_err("pastebin does not have raw URLs: $url");
		} else {
			print "$raw\n";
		}
	} else {
		if ($handler) {
			my $output = $handler->($raw, @hargs);
			if (defined $output) {
				print "$output\n";
			} else {
				_err("paste extraction failed");
			}
		} else {
			getprint $raw;
		}
	}
}

exit $::errors;
