#!/usr/bin/env perl
use warnings;
use strict;
use File::Basename;
use Getopt::Long qw(:config gnu_getopt);
use Image::Size;
use POSIX;
use Nullroute::Lib;

my $qr_y_m_d = qr/\d{4}-\d{2}-\d{2}/;

my $host;
my $force;
my $force_host;
my $dry_run = 0;
my $do_prefix = 0;

sub usage {
	print for
	"Usage: $::arg0 [options] <file...>\n",
	"\n",                     #
	"  -f, --force            Rename non-matching files (based on mtime)\n",
	"  -n, --dry-run          Only show what would have been done\n",
	"\n",
	"  -h, --host=STR         Suffix a host name or some other label\n",
	"  --force-host=STR       Likewise but has something to do with --force?\n",
	"  -F, --prefix           Prefix current name (instead of replacing)\n",
	;
}

sub do_file {
	my ($file) = @_;
	_debug("processing file '$file'");

	my ($old_name, $dir, $suffix) = fileparse($file, qr/\.[^.]+$/);
	my $new_name = $old_name;

	for ($new_name) {
		my @stat = stat($file);
		if (!@stat) {
			_err("could not stat '$file': $!");
			next;
		}
		my @mtime = localtime($stat[9]);

		# arbitrary (host given in command line) â€“ OneDrive, imgur, etc.
		if ($force || $force_host) {
			my $tail = $force_host ? ".$force_host" : "";
			s/.*/strftime("Screenshot_%Y-%m-%d_%H%M%S", @mtime).$tail/e;
			last;
		}

		# mpv
		if (/^(?:gnome-)?mpv-shot.*(\.[^.]+)$/) {
			s//strftime("Screenshot_%Y-%m-%d_%H%M%S", @mtime).$1/e;
			last;
		}
	}

	_debug(" first stage => '$new_name'");

	# normalize to Y-M-D.hms
	for ($new_name) {
		my $tail = $host ? ".$host" : "";
		$tail .= " - $old_name" if $do_prefix;

		# Output of stage 1
		s/^Screenshot_($qr_y_m_d)_(\d{2})(\d{2})(\d{2})\b/$1.$2$3$4$tail/;

		# Dropbox on Windows
		# "Screenshot 2018-05-12 21.52.18.png"
		s/^Screenshot ($qr_y_m_d) (\d+)\.(\d+)\.(\d+)\b/$1.$2$3$4$tail/;

		# GNOME Shell
		# "Screenshot from 2018-10-14 14-36-34.png"
		# "Screencast from 2013-09-04 00:49:14.webm"
		s/^Screenshot from ($qr_y_m_d) (\d+)[:-](\d+)[:-](\d+)\b/$1.$2$3$4$tail/;
		s/^Screencast from ($qr_y_m_d) (\d+)[:-](\d+)[:-](\d+)\b/$1.$2$3$4$tail/;

		# Android
		#$tail ||= ".nexus";
		# "Screenshot_20150514.172546.png"
		# "Screenshot_20160417-124530.png"
		s/^Screenshot_(\d{4})(\d{2})(\d{2})[.-](\d{6})\b/$1-$2-$3.$4$tail/;
	}

	_debug(" second stage => '$new_name'");

	$old_name .= $suffix;
	$new_name .= $suffix;

	if ($new_name eq $old_name) {
		return;
	} elsif (-e $new_name) {
		_err("not renaming '$old_name' to '$new_name': target already exists");
	} elsif ($dry_run) {
		_info("would rename '$dir$old_name' to '$new_name'");
	} else {
		_info("renaming '$dir$old_name' to '$new_name'");
		if (!rename($dir.$old_name, $dir.$new_name)) {
			_err("rename '$old_name' to '$new_name': !! $!");
		}
	}
}

sub do_dir {
	my (@dirs) = reverse @_;
	_debug("processing dirs [@dirs]");

	while (@dirs) {
		my $dir = pop @dirs;
		my @next = ();
		_debug("reading '$dir'");
		if (opendir(my $dh, $dir)) {
			for my $name (sort readdir($dh)) {
				my $path = "$dir/$name";

				if ($name eq "." || $name eq "..") {
					next;
				}
				elsif (-d $path) {
					# queue?
					push @next, $path;
					# recursion?
					#do_dir($path);
				}
				elsif (-f $path) {
					do_file($path);
				}
			}
			closedir($dh);
		} else {
			_err("cannot open directory '$dir': $!");
		}
		if (@next) {
			push @dirs, reverse @next;
		}
	}
}

GetOptions(
	"help" => sub { usage(); exit },
	"n|dry-run!" => \$dry_run,
	"f|force!" => \$force,
	"force-host=s" => \$force_host,
	"h|host=s" => \$host,
	"F|prefix!" => \$do_prefix,
) or exit(2);

my @args = @ARGV;

if (!@args) {
	@args = (".");
}

for (@args) {
	_debug("processing arg '$_'");
	if (-d) {
		do_dir($_);
	} else {
		do_file($_);
	}
}

Nullroute::Lib::_exit();
