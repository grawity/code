#!/usr/bin/env perl
use warnings;
use strict;
use File::Basename;
use Getopt::Long qw(:config gnu_getopt);
use Image::Size;
use POSIX;
use Nullroute::Lib;

my $qr_y_m_d = qr/\d{4}-\d{2}-\d{2}/;

my $host;
my $force;
my $force_host;
my $dry_run = 0;

sub do_file {
	my ($file) = @_;
	_debug("processing file '$file'");

	my ($old_name, $dir, $suffix) = fileparse($file, qr/\.[^.]+$/);
	my $new_name = $old_name;

	for ($new_name) {
		my @stat = stat($file);
		if (!@stat) {
			_err("could not stat '$file': $!");
			next;
		}
		my @mtime = localtime($stat[9]);

		# arbitrary (host given in command line) â€“ OneDrive, imgur, etc.
		if ($force || $force_host) {
			my $tail = $force_host ? ".$force_host" : "";
			s/.*/strftime("Screenshot_%Y-%m-%d_%H%M%S", @mtime).$tail/e;
			last;
		}

		# mpv
		if (/^(?:gnome-)?mpv-shot.*(\.[^.]+)$/) {
			s//strftime("Screenshot_%Y-%m-%d_%H%M%S", @mtime).$1/e;
			last;
		}
	}

	# normalize to Y-M-D.hms

	for ($new_name) {
		my $tail = $host ? ".$host" : "";

		# stage 1
		s/^Screenshot_($qr_y_m_d)_(\d{2})(\d{2})(\d{2})/$1.$2$3$4$tail/;
		# Dropbox on Windows
		s/^Screenshot ($qr_y_m_d) (\d+)\.(\d+)\.(\d+)/$1.$2$3$4$tail/;
		# GNOME Shell
		s/^Screenshot from ($qr_y_m_d) (\d+)[:-](\d+)[:-](\d+)/$1.$2$3$4$tail/;
	}

	$old_name .= $suffix;
	$new_name .= $suffix;

	if ($new_name eq $old_name) {
		return;
	} elsif (-e $new_name) {
		_err("not renaming '$old_name' to '$new_name': target already exists");
	} elsif ($dry_run) {
		_info("would rename '$dir$old_name' to '$new_name'");
	} else {
		_info("renaming '$dir$old_name' to '$new_name'");
		if (!rename($dir.$old_name, $dir.$new_name)) {
			_err("rename '$old_name' to '$new_name': !! $!");
		}
	}
}

sub do_dir {
	my (@dirs) = reverse @_;
	_debug("processing dirs [@dirs]");

	while (@dirs) {
		my $dir = pop @dirs;
		my @next = ();
		_debug("reading '$dir'");
		if (opendir(my $dh, $dir)) {
			for my $name (sort readdir($dh)) {
				my $path = "$dir/$name";

				if ($name eq "." || $name eq "..") {
					next;
				}
				elsif (-d $path) {
					# queue?
					push @next, $path;
					# recursion?
					#do_dir($path);
				}
				elsif (-f $path) {
					do_file($path);
				}
			}
			closedir($dh);
		} else {
			_err("cannot open directory '$dir': $!");
		}
		if (@next) {
			push @dirs, reverse @next;
		}
	}
}

GetOptions(
	"n|dry-run!" => \$dry_run,
	"f|force!" => \$force,
	"force-host=s" => \$force_host,
	"h|host=s" => \$host,
) or exit(2);

my @args = @ARGV;

if (!@args) {
	@args = (".");
}

for (@args) {
	_debug("processing arg '$_'");
	if (-d) {
		do_dir($_);
	} else {
		do_file($_);
	}
}

Nullroute::Lib::_exit();
