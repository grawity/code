#!/usr/bin/env bash
# pull - update version control repositories to latest upstream versions

# fetch.output compact
# merge.stat off

. lib.bash || exit

set -u

log:() {
	"$@" || err "command '$1' failed (status $?)"
}

svnsync() {
	local lib=$(which libfunsync.so 2>/dev/null)

	if [[ -f $lib ]]; then
		env LD_PRELOAD="$lib" svnsync "$@"
	else
		env svnsync "$@"
	fi
}

do_git() {
	if [[ -d .git/svn ]]; then
		if remote=$(git config --get svn-remote.svn.url); then
			rroot=$(log: svn info "$remote" | sed -n 's/^Repository Root: //p')
			if [[ $rroot == file://* ]]; then
				log: svnsync sync "$rroot"
			fi
		fi
		ref=$(git config --get svn-remote.svn.fetch)
		ref=${ref#*:}
		ref=${ref:-refs/remotes/git-svn}
		old=$(git rev-parse --verify HEAD)
		log: git svn fetch &&
		log: git merge --ff-only "$ref" || return
		new=$(git rev-parse --verify HEAD)
	elif [[ -e .git ]]; then
		sparse=$(git config --type bool core.sparseCheckout || echo false)
		case $sparse in
			true) recurseopt='--recurse-submodules=no';;
			*) recurseopt='';
		esac
		old=$(git rev-parse --verify HEAD)
		log: git pull --ff-only --no-stat $recurseopt || return
		new=$(git rev-parse --verify HEAD)
		if [[ -e .gitmodules ]] && [[ $sparse != true ]]; then
			log: git submodule update
		fi
	elif [[ "$(git config core.bare)" == "true" ]]; then
		old=$(git rev-parse --verify HEAD)
		git fetch || return
		new=$(git rev-parse --verify HEAD)
	fi

	if [[ "$old" != "$new" ]]; then
		local diff_paths=(":!fuzz/*" ":!test*/*" ":!vendor/*")
		mapfile -t -O ${#diff_paths[@]} diff_paths \
			< <(git config --get-all nullroute.git-new.paths)
		local diff_args=("$old..$new" -- "${diff_paths[@]}")
		git --no-pager diff --stat "${diff_args[@]}"

		if (( opt_tig )); then
			revs=$(git rev-list --count "${diff_args[@]}")
			# Only run tig if there are commits to show, as
			# otherwise it still triggers the 'focus' \e[I and
			# there's no Bash prompt to consume that.
			if (( revs )); then
				local tig_opts=()
				mapfile -t tig_opts \
					< <(git config --get-all nullroute.git-new.options)
				tig "${tig_opts[@]}" "${diff_args[@]}" || true
			else
				vmsg "no interesting commits to show"
			fi
		fi
	fi
}

do_pullfile() {
	local -A skip_dirs=()
	local skip_args=
	local skip_glob=

	if [[ -s Pullfile ]]; then
		set -- $(grep '^[^#]' Pullfile)
	elif [[ -e Pullfile ]]; then
		set -- */
	else
		set -- .
	fi

	for arg; do
		arg=${arg%/}
		case $arg in
		!*)
			arg=${arg#!}
			debug "Excluding glob '$arg'"
			skip_args+="|$arg"
			skip_glob="@(${skip_args#|})"
			;;
		-*)
			arg=${arg#-}
			arg=$(realpath "$arg")
			debug "Excluding path '$arg'"
			skip_dirs[$arg]=1
			;;
		*)
			if [[ $skip_glob && $arg == $skip_glob ]]; then
				debug "Skipping '$arg' (matches exclude)"
				continue
			fi
			arg=$(realpath "$arg")
			if [[ ! -d $arg ]]; then
				warn "Skipping '$arg' (not a directory)"
				continue
			fi
			if [[ ${skip_dirs[$arg]-} ]]; then
				debug "Skipping '$arg' (path excluded)"
				continue
			fi
			(cd "$arg" && main)
			;;
		esac
	done
}

main() {
	local argdepth=${argdepth:-0}
	local rdir=

	# Determine relative path for display purposes
	rdir=$(realpath --relative-to="$_PULL_STARTDIR" "$PWD")
	if [[ $rdir == . ]]; then
		rdir=$PWD
	fi

	# Check cwd for supported repositories
	if [[ -f Pullfile ]]; then
		if (( opt_list > 1 && argdepth > 0 )); then
			echo "$rdir"
		elif (( opt_dryrun > 1 && argdepth > 0 )); then
			vmsg "Would descend into '$rdir'" >&2
		else
			(let argdepth+=1; do_pullfile)
		fi
	elif [[ -d .git ]]; then
		if (( opt_list )); then
			echo "$rdir"
		elif (( opt_dryrun )); then
			vmsg "Would update '$rdir'" >&2
		else
			log2 "Updating '$rdir'"
			do_git || err "Update failed for '$rdir'"
		fi
	else
		if (( opt_dryrun )); then
			vmsg "Would fail '$rdir'" >&2
		else
			log2 "Updating '$rdir'"
			err "Not a repository: '$rdir'"
		fi
	fi
}

usage() {
	echo "Usage: $progname [-lnt] [DIR...]"
	echo
	echo_opt "-l"	"only list paths to be updated (implies '-n')"
	echo_opt "-n"	"dry run (parse Pullfile but don't update anything)"
	echo_opt "-nn"	"dry run (do not recurse)"
	echo_opt "-t"	"immediately run 'tig' to browse commits"
}

# Remember original starting directory for displaying subdirs
_PULL_STARTDIR=$PWD

opt_dryrun=0
opt_list=0
opt_tig=0

while getopts ":lnt" OPT; do
	case $OPT in
	l) let ++opt_list;;
	n) let ++opt_dryrun;;
	t) let ++opt_tig;;
	*) lib:die_getopts;;
	esac
done; shift $((OPTIND-1))

if (( opt_tig )) && ! have tig; then
	vdie "tig is not installed"
fi

(( $# )) || set -- .

for arg; do
	if [[ -d $arg ]]; then
		(cd "$arg" && main)
	else
		vdie "path is not a directory: $arg"
	fi
done
