#!/usr/bin/env bash
# on, @ -- Run commands on another host
#
# This is like 'ssh -t <host>', but preserves the current directory.
#
#   - If called as '@' or '@foo', it will just preserve cwd exactly, i.e.
#     remote commands will act on remote files.
#     (For example, 'cd ~/Dropbox; @ ember wget ...')
#
#   - If called as 'on' or '@@', it will try to access the *local* cwd via NFS,
#     i.e. remote commands will still act on local files.
#     (For example, 'cd ~src/systemd; on buildbox ninja')
#
# Accepts '@foo' symlinks (hostname in argv[0]) like ssh/rsh.
#
# Kind of inspired by the SunOS /tmp story from:
# https://www-uxsup.csx.cam.ac.uk/misc/horror.txt
#
# Apparently the 'on' command did indeed exist:
# http://www.bitsavers.org/pdf/sun/sunos/3.4/800-1295-04A_Commands_Reference_Manual_198609.pdf#page=290

. lib.bash || exit

arg0=${0##*/}
pwd=$PWD
nfs=0

if [[ $arg0 == @@?* ]]; then
	host=${arg0#@@}
	nfs=1
elif [[ $arg0 == @(@@|on) && $1 ]]; then
	host=$1; shift
	nfs=1
elif [[ $arg0 == @?* ]]; then
	host=${arg0#@}
elif [[ $arg0 == @ && $1 ]]; then
	host=$1; shift
else
	host=$arg0
	pwd=""
fi

while getopts ":d:n" OPT; do
	case $OPT in
	d) pwd=$OPTARG;;
	n) nfs=1;;
	*) lib::die_getopts;;
	esac
done; shift $((OPTIND-1))

# Optionally trim loopback symlinks (ember:/net/ember/foo -> ember:/foo)
pwd=${pwd/#"/net/$host/"/"/"}

if (( nfs )); then
	if [[ $pwd != /net/* ]]; then
		if [[ ! -e /proc/fs/nfsd/versions ]]; then
			die "NFS service not running on $HOSTNAME"
		fi
		pwd="/net/$HOSTNAME$pwd"
	fi
	info "Running in $host:$pwd"
fi

if [[ $pwd ]]; then
	qpwd=${pwd@Q}
else
	qpwd=""
fi

# 0 args - run a shell
# 1 arg - use as raw command line
# 2+ args - quote individual args

if (( $# == 0 )); then
	qcmd="bash"
elif (( $# == 1 )) && [[ $1 == *\ * ]]; then
	qcmd="$1"
else
	qcmd="${@@Q}"
fi

if [[ -t 0 && -t 1 && -t 2 ]]; then
	tty_arg="-t"
else
	tty_arg=""
fi

exec ssh -K -q $tty_arg "$host" "export SILENT=1; . ~/.profile && cd $qpwd && ($qcmd)"
