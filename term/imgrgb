#!/usr/bin/env perl
# Image viewer for terminals that support true colors.
# (c) 2020 Mantas Mikulėnas <grawity@gmail.com>
#
# Based on vte/perf/img.sh
# (c) 2014 Egmont Koblinger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use Getopt::Long;

my $sep1 = ":";
my $sep2 = "::";

GetOptions(
	"colon4|official|dejure" => sub { },
	"colon3|wrong" => sub { $sep2 = ":"; },
	"semicolon|common|defacto" => sub { $sep1 = $sep2 = ";"; },
) || exit(2);

if (!@ARGV) {
	print "Usage: imgrgb [--format] imagefile\n";
	print "\n";
	print "  --colon4|--official|--dejure:    Official format (default)  \\e[38:2::R:G:Bm\n";
	print "  --colon3|--wrong:                Misinterpreted format      \\e[38:2:R:G:Bm\n";
	print "  --semicolon|--common|--defacto:  Commonly used format       \\e[38;2;R;G;Bm\n";
	exit(2);
}

if (!grep {-x "$_/magick"} split(/:/, $ENV{PATH})) {
	warn "Please install ImageMagick to run this script.\n";
	exit(1);
}

my $COLUMNS = int(`tput cols`);

my @cmd = ("magick", "convert", "-thumbnail", "${COLUMNS}x", "-define", "txt:compliance=SVG", $ARGV[0], "txt:-");

my @upper = ();
my @lower = ();
my $buf = "";

if (open(my $fh, "-|", @cmd)) {
	while (my $line = <$fh>) {
		if ($line =~ /^(\d+),(\d+): \(.+\)  #([0-9A-F]+)  /) {
			my $col = int($1);
			my $row = int($2);
			my $rgb = hex($3);
			my $r = ($rgb >> 24) & 0xFF;
			my $g = ($rgb >> 16) & 0xFF;
			my $b = ($rgb >>  8) & 0xFF;

			if (@lower && $col == 0) {
				# Show previous line.
				for my $i (0..@lower-1) {
					$buf .= "\e[38${sep1}2${sep2}${upper[$i]};48${sep1}2${sep2}${lower[$i]}m▀";
				}
				$buf .= "\e[0m\e[K\n";
				@upper = ();
				@lower = ();
			}

			if ($row % 2) {
				$lower[$col] = "$r$sep1$g$sep1$b";
			} else {
				$upper[$col] = "$r$sep1$g$sep1$b";
			}
		} elsif ($line !~ /^#/) {
			warn "bad line: $line";
		}
	}
	# Print the last (half-)line, if required.
	if (@lower) {
		for my $i (0..@lower-1) {
			$buf .= "\e[38${sep1}2${sep2}${upper[$i]};48${sep1}2${sep2}${lower[$i]}m▀";
		}
		$buf .= "\e[0m\e[K\n";
	} elsif (@upper) {
		for my $i (0..@upper-1) {
			$buf .= "\e[38${sep1}2${sep2}${upper[$i]}m▀";
		}
		$buf .= "\e[0m\e[K\n";
	}
	print $buf;
	close($fh);
} else {
	warn "Failed to run magick convert\n";
	exit(1);
}
