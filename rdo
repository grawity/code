#!/usr/bin/env bash
# rdo -- run a command across all hosts

. lib.bash || exit

usage() {
	echo "Usage: $progname [-C path] [-H hosts] [-SW] <command>"
	echo
	echo "Run a command simultaneously on all hosts."
	echo
	echo_opt "-C path"	"working directory"
	echo_opt "-H hosts"	"list of hosts to connect to"
	echo_opt "-S"		"connect as superuser (root)"
	echo_opt "-W"		"output in order (disables parallel output)"
	# XXX: We could still invoke the commands in parallel and only show
	# output in order, after all have returned. This might increase the
	# perceived delay, though, so it should be -WW or something.
}

cwd=
nfs=0
hosts=
user=
wait=0

while getopts ":C:H:NSW" OPT; do
	case $OPT in
	C) cwd=$OPTARG;;
	H) hosts=${OPTARG//,/ };;
	N) nfs=1;;
	S) user="root@";;
	W) wait=1;;
	*) lib:die_getopts;;
	esac
done; shift $((OPTIND-1))

hosts=$(rlisthosts "$hosts") || exit

if (( ! $# )); then
	die "command not specified"
elif (( $# == 1 )); then
	cmd=$1
else
	cmd=${*@Q}
fi

if (( nfs )); then
	# "-N" implies "-C ." in order to be useful
	cwd=${cwd:-"."}
fi

if [[ $cwd ]]; then
	# Allow "-C ." to be specified in a useful way
	if [[ $cwd != /* ]]; then
		cwd=$(realpath -s "$cwd")
	fi
	if (( nfs )); then
		cwd="/net/$HOSTNAME/${cwd#/net/*/}"
	fi
fi

# Make sure to show return code on failure. (XXX: This could probably also be
# done locally, as ssh propagates the exit status.)
cwd=${cwd:-"."}
cmd="(cd ${cwd@Q} && ${cmd:-:}) 2>&1 || echo '=> '\$?"

for host in $hosts; do
	(
		out=$(mktemp /tmp/rdo.XXXXXXXX) || exit
		echo -n "$host:" > "$out"
		ssh -n $user$host "$cmd" |
			awk '{print "\t"$0} END {if (!NR) print}' >> "$out"
		flock /dev/stdout cat "$out"
		rm -f "$out"
	) &
	if (( wait )); then wait; fi
done
wait
