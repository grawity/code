#!/usr/bin/env perl
# getpaste r11 - Retrieves raw text from a pastebin
# Released under WTFPL v2 <http://sam.zoy.org/wtfpl/>
use warnings;
use strict;
no locale;
use JSON;
use LWP::Simple;
use MIME::Base64;

# Stolen from URI::Split
sub uri_split {
	my $str = shift;

	$str =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
}

sub decode_html {
	my $str = shift;

	$str =~ s/&lt;/</g;
	$str =~ s/&gt;/>/g;
	$str =~ s/&quot;/"/g;
	$str =~ s/&amp;/\&/g;
	return $str;
}

sub try_decode_json {
	my $data = shift;

	ref $data ? $data : decode_json($data);
}

sub sjcl_decrypt {
	require Crypt::AuthEnc::CCM; # CryptX
	require Crypt::KeyDerivation; # CryptX

	Crypt::AuthEnc::CCM->import(":all");
	Crypt::KeyDerivation->import("pbkdf2");

	my ($frag, $json) = @_;

	my $data = try_decode_json($json);
	my $salt = decode_base64($data->{salt});
	my $ct   = decode_base64($data->{ct});
	my $iv   = decode_base64($data->{iv});

	my $key = pbkdf2($frag, $salt, 1000, "SHA256", 128/8);

	my $tag = substr($ct, -8, 8, "");

	return ccm_decrypt_verify("AES", $key, $iv, "", $ct, $tag)
	       // _die("decryption failed");
}

sub lzw_decompress {
	my ($buf) = @_;

	return $buf; # TODO
}

sub dl_0bin {
	my ($url, $frag) = @_;

	my $body = get($url);
	$body =~ m{<code>\n\s*(\{.+\})\n\s*</code>} || return;

	my $data = decode_html($1);
	# the URL fragment is *not* decoded before passing to KDF
	$data = sjcl_decrypt($frag, $data);
	$data = decode_base64($data);
	# currently 0bin does not compress with LZW anymore
	#$data = lzw_decompress($data);
	return $data;
}

sub dl_hastebin {
	my ($url) = @_;

	my $json = get($url);
	my $data = decode_json($json);
	return $data->{data};
}

sub parse_url {
	my ($url) = @_;
	my ($scheme, $host, $path, $query, $frag) = uri_split $url;
	$path =~ s|^/||;

	if ($host =~ /^sprunge\.us$/)
		{ return $url }

	elsif ($host =~ /^codepad\.org$/ and $path =~ m!^(\w+)!)
		{ return "http://$host/$1/raw.txt" }

	elsif ($host =~ /^dpaste\.(org|de)$/ and $path =~ m!^(\w+)!)
		{ return "http://$host/$1/raw/" }

	elsif ($host =~ /^dpaste\.com$/ and $path =~ m!^(?:hold/)?(\d+)!)
		{ return "http://$host/$1/plain/" }

	elsif ($host =~ /^(?:[\w-]+\.)?pastebin\.ca$/ and $path =~ m!^(?:raw/)?(\d+)!)
		{ return "http://$host/raw/$1" }

	elsif ($host =~ /^pastebin\.com$/ and $path =~ m!^(?:index/)?(\w+)!)
		{ return "http://$host/download.php?i=$1" }

	elsif ($host =~ /^pastebin(\.centos|\.mozilla)?\.org$/
		and $path =~ m!^(?:pastebin\.php\?dl=)?(\d+)!)
		{ return "http://$host/pastebin.php?dl=$1" }

	elsif ($host =~ /^paste\.linuxassist\.net$/ and $path =~ m!(\d+)!)
		{ return "http://linux:linux\@$host/pastebin.php?raw=$1" }

	elsif ($host =~ /^pastie\.org$/ and $path =~ m!^(\d+)!)
		{ return "http://$host/pastes/$1/download" }

	elsif ($host =~ /(?:dark-)?code\.bulix\.org$/ and $path =~ m!^(\w+-\d+)!)
		{ return "http://$host/$1?raw" }

	elsif ($host =~ /^fpaste\.org$/ and $path =~ m!^(\w+)!)
		{ return "http://$host/$1/raw/" }

	elsif ($host =~ /^paste\.fedoraproject\.org$/)
		{ return "http://$host/$path/raw" }

	elsif ($host =~ /^pastebin\.de$/ and $path =~ m!^(\d+)!)
		{ return "http://$host/download/?id=$1" }

	elsif ($host =~ /^privatepaste\.com$/ and $path =~ m!^(\w+)!)
		{ return "http://$host/download/$1" }

	elsif ($host =~ /^gist\.github\.com$/)
		{ return "https://$host/$path.txt" }

	elsif ($host =~ /^hastebin\.com$/ and $path =~ m!^(\w+)!)
		{ "http://hastebin.com/documents/$1", \&dl_hastebin }

	elsif ($host =~ /^0bin\.net$/)
		{ $url, sub { dl_0bin(shift, $frag) } }

	else
		{ return undef }
}

my $showurl = ($ARGV[0] eq "-u");
shift @ARGV if $showurl;

if (!@ARGV) {
	warn "Usage: getpaste [-u] <url>\n";
	exit 2;
}

my $err = 0;

for my $url (@ARGV) {
	my ($raw, $handler) = parse_url($url);
	if (!defined $raw && !defined $handler) {
		warn "Unknown pastebin: $url\n";
		++$err;
	} elsif ($showurl) {
		if ($handler) {
			print "#unavailable\n";
		} else {
			print "$raw\n";
		}
	} else {
		if ($handler) {
			print $handler->($raw)."\n";
		} else {
			getprint $raw;
		}
	}
}

exit $err;
