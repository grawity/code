#!/usr/bin/env bash
# vim: ts=2:sw=2:et

# Image viewer for terminals that support true colors.
# Copyright (C) 2014  Egmont Koblinger
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

sep1=':'
sep2='::'
if [ "$1" = "-colon4" -o "$1" = "-official" -o "$1" = "-dejure" ]; then
  shift
elif [ "$1" = "-colon3" -o "$1" = "-wrong" ]; then
  sep2=':'
  shift
elif [ "$1" = "-semicolon" -o "$1" = "-common" -o "$1" = "-defacto" ]; then
  sep1=';'
  sep2=';'
  shift
fi

if [ $# != 1 -o "${1:0:1}" = "-" ]; then
  echo 'Usage: img.sh [-format] imagefile' >&2
  echo >&2
  echo '  -colon4|-official|-dejure:    Official format (default)  \e[38:2::R:G:Bm' >&2
  echo '  -colon3|-wrong:               Misinterpreted format      \e[38:2:R:G:Bm' >&2
  echo '  -semicolon|-common|-defacto:  Commonly used format       \e[38;2;R;G;Bm' >&2
  exit 1
elif [ -z $(type -p magick) ]; then
  echo 'Please install ImageMagick to run this script.' >&2
  exit 1
fi

# This is so that "upper" is still visible after exiting the while loop.
shopt -s lastpipe

COLUMNS=$(tput cols)

declare -a upper lower
upper=()
lower=()

magick convert -thumbnail ${COLUMNS}x -define txt:compliance=SVG "$1" txt:- |
while IFS=',:() ' read col row dummy dummy_r dummy_g dummy_b dummy_a hex rest; do
  if [ "$col" = "#" ]; then
    continue
  fi

  red=$(( 0x${hex:1:2} ))
  green=$(( 0x${hex:3:2} ))
  blue=$(( 0x${hex:5:2} ))

  if [ $((row%2)) = 0 ]; then
    upper[$col]="$red$sep1$green$sep1$blue"
  else
    lower[$col]="$red$sep1$green$sep1$blue"
  fi

  # After reading every second image row, print them out.
  if [ $((row%2)) = 1 -a $col = $((COLUMNS-1)) ]; then
    i=0
    buf=''
    while [ $i -lt $COLUMNS ]; do
      buf+="\\e[38${sep1}2${sep2}${upper[$i]};48${sep1}2${sep2}${lower[$i]}m▀"
      i=$((i+1))
    done
    # \e[K is useful when you resize the terminal while this script is still running.
    buf+="\\e[0m\e[K"
    echo -e "$buf"
    upper=()
    d=()
  fi
done

# Print the last half line, if required.
if [ "${upper[0]}" != "" ]; then
  i=0
  while [ $i -lt $COLUMNS ]; do
    echo -ne "\\e[38${sep1}2${sep2}${upper[$i]}m▀"
    i=$((i+1))
  done
  echo -e "\\e[0m\e[K"
fi
