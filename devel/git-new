#!/usr/bin/env bash
# git-new - show new commits in a branch, based on the reflog

. lib.bash || exit

if [[ $PWD == $HOME/src/* ]]; then
	dir=$(git rev-parse --git-dir) || exit
	ssum() {
		[[ -e "$dir/$2" ]] &&
		echo "$1  $dir/$2" | sha1sum --check --quiet 2>/dev/null
	}
	if ssum 9635f1b7e12c045212819dd934d809ef07efa2f4  description; then
		rm -vf "$dir/description"
	fi
	if ssum b614c2f63da7dca9f1db2e7ade61ef30448fc96c  hooks/post-update; then
		rm -vf "$dir/hooks/post-update"
	fi
	rm -vf "$dir/info/refs"
	fetch=$(git config --get-all remote.origin.fetch)
	if [[ "$fetch" == "+refs/*:refs/*" ]]; then
		warn "refspec '$fetch' may allow tag deletion"
		fetch="+refs/heads/*:refs/heads/*"
		if confirm "change to '$fetch'?"; then
			git config --unset-all remote.origin.fetch
			git config --unset-all remote.origin.mirror
			git config remote.origin.fetch "$fetch"

			git for-each-ref --format="%(refname)" |
			egrep -v '^refs/(heads|notes|tags)/' | {
				declare refs=()
				while read -r ref; do
					echo "found junk ref '$ref'"
					refs+=("$ref")
				done
				if (( ${#refs[@]} )) && confirm "purge refs?"; then
					for ref in "${refs[@]}"; do
						git update-ref -d "$ref"
					done
				fi
			}
		fi
	elif [[ ! "$fetch" ]]; then
		fetch="+refs/heads/*:refs/heads/*"
		warn "refspec not set; changing to '$fetch'"
		git config remote.origin.fetch "$fetch"
	fi
	rdempty --quiet "$dir"
fi

migrate_opt() {
	local old=$1 new=$2
	local val=$(git config "$old" || true)
	if [[ "$val" ]]; then
		info "migrating option '$old' -> '$new'"
		git config "$new" "$val" &&
		git config --unset "$old"
	fi
}

migrate_opt nullroute.{git.up,git-new.options}
migrate_opt nullroute.git-new.{opts,options}
migrate_opt nullroute.git-new.{args,paths}

opts=$(git config nullroute.git-new.options || true)
paths=$(git config nullroute.git-new.paths || true)

if [[ -t 1 ]] && which tig >/dev/null 2>&1; then
	cmd='tig'
else
	cmd='git lg'
fi

ref=${1:-HEAD}

if [[ $ref != HEAD ]]; then
	# explicit check is faster than letting tig do it
	if ! git rev-parse --verify "$ref" >/dev/null 2>&1; then
		echo "error: bad ref '$ref'" >&2
		exit 1
	fi
fi

exec $cmd $opts "^$ref@{1}" "$ref" "${@:2}" -- $paths
