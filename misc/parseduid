#!/usr/bin/env python3
# decode -- tool for decoding various structured binary identifiers
#
# (This should eventually incorporate 'nsap' and 'parse-snmp-engine-id'.)
import argparse
import binascii
import datetime
import enum
import io
import ipaddress
import uuid
from nullroute.io import BinaryReader

# https://www.iana.org/assignments/arp-parameters/arp-parameters.xhtml#arp-parameters-2
class ArpHardwareType(enum.IntEnum):
    NonHardware = 0 # Defined for DHCP client identifiers (RFC 2132)
    Ethernet = 1
    Ieee802 = 6     # *Sometimes* used for Wi-Fi aka IEEE 802.11
    Ieee1394 = 24   # FireWire

# https://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml#dhcpv6-parameters-6
class DUIDType(enum.IntEnum):
    LLT = 1         # Link-Layer + Time (RFC 3315)
    EN = 2          # Enterprise Number (RFC 3315)
    LL = 3          # Link Layer (RFC 3315)
    UUID = 4        # Universally Unique ID (RFC 6355)

# https://datatracker.ietf.org/doc/html/rfc4446#section-3.2
class PseudowireType(enum.IntEnum):
    TaggedEthernet  = 0x0004
    Ethernet        = 0x0005

# https://datatracker.ietf.org/doc/html/rfc4446#section-3.3
class PseudowireInterfaceParamSubTlvType(enum.IntEnum):
    InterfaceMTU    = 0x01

# https://datatracker.ietf.org/doc/html/rfc4446#section-3.4.2
class PseudowireAttachmentGroupType(enum.IntEnum):
    RouteDistinguisher  = 0x01

# https://datatracker.ietf.org/doc/html/rfc4446#section-3.4.1
class PseudowireAttachmentIndividualType(enum.IntEnum):
    LocalIdentifier     = 0x01

def try_enum(etype, value):
    try:
        return etype(value)
    except ValueError:
        return value

def show_enum(value, fmt="%d"):
    if hasattr(value, "name"):
        return ("%s (" + fmt + ")") % (value.name, value)
    else:
        return ("%s (" + fmt + ")") % ("unknown", value)

def lookup_iana_pen(vendor):
    return {
        43793: "systemd (Tom Gundersen)",
    }.get(vendor, "unknown")

def parse_hex(s):
    if ":" in s:
        s = s.split(":")
        s = [int(c, 16) for c in s]
        return bytes(s)
    else:
        s = s.replace("-", "")
        s = s.replace(" ", "")
        return binascii.unhexlify(s)

def fmt_hex(buf):
    h = ["%02x" % c for c in buf]
    h = ":".join(h).upper()
    return h or "(empty)"

def is_ascii(buf):
    return all(0x20 < x < 0x7F for x in buf)

def print_hdr(hdr):
    print("\033[1m%s\033[m" % hdr)

def decode_dhcp_client_id(buf):
    # https://tools.ietf.org/html/rfc2132#section-9.14
    # Types (except 0 and 255) correspond to link-layer types, 1 is Ethernet
    print_hdr("DHCP Client Identifier")
    br = BinaryReader(buf)
    type = br.read_u8()
    type = try_enum(ArpHardwareType, type)
    if type == 0x00:
        print("Type:", "non-hardware (%d)" % type)
        ident = br.fh.read()
        if is_ascii(ident):
            print("  Identifier:", repr(ident))
        else:
            print("  Identifier:", fmt_hex(ident))
    elif type == 0xFF:
        # https://tools.ietf.org/html/rfc4361#section-6.1
        print("Type:", "embedded RFC 3315 IAID+DUID (%d)" % type)
        iaid = br.read(4)
        print("  IAID:", fmt_hex(iaid))
        duid = br.fh.read()
        print("  DUID:", fmt_hex(duid))
        print("  -- Decoding nested DUID --")
        decode_dhcpv6_duid(duid)
    elif type == 0x01 and len(buf) == (1 + 16) and buf[1:5] == b'RAS ':
        print("Type:", "Windows RRAS dial-in pool lease")
        magic = br.read(4)
        print("  Magic:", repr(magic))
        mac = br.read(6)
        print("  Server MAC:", fmt_hex(mac))
        foo = br.read(2)
        print("  Unknown field:", fmt_hex(foo))
        rest = br.fh.read()
        print("  RAS port number:", fmt_hex(rest))
    else:
        print("Type:", "link-layer address (%s) (%d)" % (type.name, type))
        mac = br.fh.read()
        print("  Link-layer address:", fmt_hex(mac))

def decode_dhcpv6_duid(buf):
    # https://tools.ietf.org/html/rfc3315#section-9.1
    print_hdr("DHCPv6 DUID")
    br = BinaryReader(buf)
    type = br.read_u16_be()
    type = try_enum(DUIDType, type)
    if type == DUIDType.LLT:
        print("Type:", "link-layer + time (DUID-LLT) (%d)" % type)
        hwtype = br.read_u16_be()
        print("  Hardware type:", "unknown (%d)" % hwtype)
        time = br.read_u32_be()
        time = datetime.datetime.fromtimestamp(time)
        print("  Time:", time)
        lladdr = br.fh.read()
        print("  Link-layer address:", fmt_hex(lladdr))
    elif type == DUIDType.EN:
        print("Type:", "vendor-assigned (DUID-EN) (%d)" % type)
        vendor = br.read_u32_be()
        print("  Vendor:", "%s (%d)" % (lookup_iana_pen(vendor), vendor))
        rest = br.fh.read()
        print("  Identifier:", fmt_hex(rest))
    elif type == DUIDType.LL:
        print("Type:", "link-layer (DUID-LL) (%d)" % type)
        hwtype = br.read_u16_be()
        hwtype = try_enum(ArpHardwareType, hwtype)
        print("  Hardware type:", hwtype)
        lladdr = br.fh.read()
        print("  Link-layer address:", fmt_hex(lladdr))
    elif type == DUIDType.UUID:
        print("Type:", "universally unique (DUID-UUID) (%d)" % type)
        buf = br.read(16)
        uid = uuid.UUID(bytes=buf)
        print("  UUID:", uid)
    else:
        print("Type:", "unknown (%d)" % type)

def decode_osi_nsap(buf):
    br = BinaryReader(buf)
    afi = br.read_u8()
    if afi == 0x47:
        print("AFI: ISO 6523-ICD IDI (%02x)" % afi)
        icd = br.read_u16_be()
        icd_name = {
            0x0005: "US Federal Government (GOSIP)",
            0x0079: "ATM Forum",
            0x0090: "IANA",
            0x0180: "Lithuania",
        }.get(icd)
        print("IDI (ICD): %s (%04x)" % (icd_name, icd))
        if icd == 0x0005:
            # 47.0005.80FFE1000000F21A26D8.0020EA000EE0.00
            print("HO-DSP (US GOSIP v2):")
            print("  DFI: %s"           % fmt_hex(br.read(1)))
            print("  AdmAuthority: %s"  % fmt_hex(br.read(3)))
            print("  Reserved: %s"      % fmt_hex(br.read(2)))
            print("  RtDomainID: %s"    % fmt_hex(br.read(2)))
            print("  AreaID: %s"        % fmt_hex(br.read(2)))
            print("ID: %s"              % fmt_hex(br.read(6)))
            print("SEL: %s"             % fmt_hex(br.read(1)))
        elif icd == 0x0091:
            print("HO-DSP (Cisco):")
            print("  %s" % fmt_hex(br.read(4)))
            print("  MAC: %s" % fmt_hex(br.read(6)))
            print("ID: %s"              % fmt_hex(br.read(6)))
            print("SEL: %s"             % fmt_hex(br.read(1)))
        else:
            print("Unknown DSP format")
    else:
        print("AFI: unknown (%02x)" % afi)

def decode_bgp_rd(buf):
    br = BinaryReader(buf)
    afi = br.read_u16_be()
    if afi == 0x0000:
        print("AFI: 2-byte ASN + 4-byte ID (0x%04x)" % afi)
        print("ASN: %d" % br.read_u16_be())
        print("ID: %d" % br.read_u32_be())
    elif afi == 0x0001:
        print("AFI: 4-byte IPv4 + 2-byte ID (0x%04x)" % afi)
        print("IPv4: %s" % ipaddress.IPv4Address(br.read(4)))
        print("ID: %d" % br.read_u16_be())
    elif afi == 0x0002:
        print("AFI: 4-byte ASN + 2-byte ID (0x%04x)" % afi)
        print("ASN: %d" % br.read_u32_be())
        print("ID: %d" % br.read_u16_be())
    else:
        print("AFI: unknown (0x%04x)" % afi)
        print("Rest: %s" % fmt_hex(br.read()))

def decode_mpls_fec(buf):
    br = BinaryReader(buf)
    fec = br.read_u8()
    if fec == 0x80:
        # https://datatracker.ietf.org/doc/html/rfc4447#section-5.2
        print("FEC element type: RFC 4446 PWid (0x%02x)" % fec)
        pw_type = br.read_u16_be()
        cw_bit = bool(pw_type & 0x8000)
        pw_type = try_enum(PseudowireType, pw_type & ~0x8000)
        print("Pseudowire type: %s" % show_enum(pw_type))
        print("Control word: %s" % cw_bit)
        info_len = br.read_u8()
        print("PW info length: [%d]" % info_len) # includes pw_id + subTLVs
        group_id = br.read_u32_be()
        print("Group ID: %d" % group_id)
        if info_len == 0:
            return
        elif info_len < 4:
            print("Pseudowire ID (too short):", fmt_hex(br.read()))
        else:
            pw_id = br.read_u32_be()
            print("Pseudowire ID: %d" % pw_id)
            info_len -= 4 # includes pw_id (but not group_id)
            while info_len:
                assert info_len >= 2, "not enough bytes for TLV type+len"
                tlv_type = br.read_u8()
                tlv_type = try_enum(PseudowireInterfaceParamSubTlvType, tlv_type)
                tlv_len = br.read_u8()
                assert tlv_len >= 2, "TLV impossibly short"
                assert tlv_len <= info_len, "not enough bytes left for TLV data"
                tlv_data = br.read(tlv_len - 2)
                print("TLV: %s = %s" % (show_enum(tlv_type, "0x%02d"), fmt_hex(tlv_data)))
                info_len -= tlv_len
    elif fec == 0x81:
        # https://datatracker.ietf.org/doc/html/rfc4447#section-5.3
        print("FEC element type: RFC 4446 Generalized PWid (0x%02x)" % fec)
        pw_type = br.read_u16_be()
        cw_bit = bool(pw_type & 0x8000)
        pw_type = try_enum(PseudowireType, pw_type & ~0x8000)
        print("Pseudowire type: %s" % show_enum(pw_type))
        print("Control word: %s" % cw_bit)
        info_len = br.read_u8()
        print("PW info length: [%d]" % info_len) # includes AGI+SAII+TAII
        if info_len == 0:
            return

        assert info_len >= 2, "not enough bytes for AGI type+len"
        agi_type = br.read_u8()
        agi_type = try_enum(PseudowireAttachmentGroupType, agi_type)
        agi_len = br.read_u8()
        info_len -= 2
        assert agi_len <= info_len, "not enough bytes left for AGI value"
        agi_value = br.read(agi_len)
        info_len -= agi_len
        print("AGI type: %s" % show_enum(agi_type))
        if agi_type == 0x01:
            decode_bgp_rd(agi_value)
        else:
            print("AGI:", fmt_hex(agi_value))

        for t in ["Source", "Dest"]:
            assert info_len >= 2, "not enough bytes for AII type+len"
            aii_type = br.read_u8()
            aii_type = try_enum(PseudowireAttachmentIndividualType, aii_type)
            aii_len = br.read_u8()
            info_len -= 2
            assert aii_len <= info_len, "not enough bytes left for AII value"
            print("%s AII type: %s (%d)" % (t, aii_type.name, aii_type))
            if aii_type == 0x01 and aii_len == 4:
                aii_value = br.read_u32_be()
                info_len -= aii_len
                print("%s AII: %s" % (t, aii_value))
            else:
                aii_value = br.read(aii_len)
                info_len -= aii_len
                print("%s AII: %s" % (t, fmt_hex(aii_value)))
    else:
        print("FEC element type: %s" % show_enum(fec))
        print("Rest: %s" % fmt_hex(br.read()))

parser = argparse.ArgumentParser()
parser.add_argument("--dhcp4", dest="type", action="store_const", const="dhcp-client-id")
parser.add_argument("--dhcp6", dest="type", action="store_const", const="dhcpv6-duid")
parser.add_argument("--bgp-rd", dest="type", action="store_const", const="bgp-rd")
parser.add_argument("--mpls-fec", dest="type", action="store_const", const="mpls-fec")
parser.add_argument("data")
args = parser.parse_args()
data = parse_hex(args.data.replace(".", ""))

if args.type == "dhcp-client-id":
    decode_dhcp_client_id(data)
elif args.type == "dhcpv6-duid":
    decode_dhcpv6_duid(data)
elif args.type == "osi-nsap":
    decode_osi_nsap(data)
elif args.type == "bgp-rd":
    decode_bgp_rd(data)
elif args.type == "mpls-fec":
    decode_mpls_fec(data)
else:
    exit("error: Unknown type %r" % args.type)
