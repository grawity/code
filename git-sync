#!/usr/bin/env bash

. lib.bash || exit

sha1() {
	printf %s "$1" | sha1sum | awk '{print $1}'
}

hash_path() {
	local path=$1

	path=$(readlink -f "$path") \
		|| die "path '$path' does not exist"
	
	sha1 "$path"
}

name_repo() {
	local path=$1

	basename "$(readlink -f "$path")"
}

add_repo() {
	local path=$1 lkey

	path=$(git -C "$path" -c core.bare=false rev-parse --show-toplevel) \
		|| die "could not determine toplevel for '$path'"
	
	lkey=$(hash_path "$path")
	
	ln -vsf "$path" "$ldir/$lkey"
}

del_repo() {
	local path=$1 lkey

	path=$(git -C "$path" -c core.bare=false rev-parse --show-toplevel) \
		|| die "could not determine toplevel for '$path'"
	
	lkey=$(hash_path "$path")

	rm -vf "$ldir/$lkey"
}

ldir=$path_config/git-sync
repos=()

if [[ -d $ldir ]]; then
	repos=("$ldir"/*)
else
	mkdir -p "$ldir"
fi

cmd=${1:-sync}; shift

case $cmd in
	sync)
		lib::is_nested -= 1
		"$0" push && "$0" pull
		;;
	pull)
		for repo in "${repos[@]}"; do
			name=$(name_repo "$repo")
			log "updating '$name' from remote"
			git -C "$repo" pull --ff-only || err "pull '$name' failed"
		done
		;;
	push)
		for repo in "${repos[@]}"; do
			name=$(name_repo "$repo")
			log "pushing '$name' to remote"
			git -C "$repo" push || err "push '$name' failed"
		done
		;;
	ls)
		for repo in "${repos[@]}"; do
			echo "$(name_repo "$repo") -> $(readlink -f "$repo")"
		done | sort
		;;
	add)
		(( $# )) || set -- "$PWD"

		for arg in "$@"; do
			add_repo "$arg"
		done
		;;
	del|rm)
		(( $# )) || set -- "$PWD"

		for arg in "$@"; do
			del_repo "$arg"
		done
		;;
	*)
		die "unknown command '$cmd'"
		;;
esac

lib::exit
