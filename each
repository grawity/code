#!/usr/bin/env bash
# each -- reverse xargs
#
# Syntax not set in stone yet. Should probably be called 'map'.
#
# Usage 1:
#
#   - for x in one two three; do frob "$x"; done
#   + each frob -- one two three
#
# Usage 2:
#
#   - find ./foo/ | xargs -I -d '\n' frob {}
#   - find ./foo/ | xargs -i frob {}
#   + find ./foo/ | each frob

usage() {
	echo "Usage: ${0##*/} <command> -- <args>"
	echo "       <input> | ${0##*/} <command>"
}

Xecho() {
	printf '%q ' "${@:1:$#-1}"
	printf '%q\n' "${!#}"
}

args=()
cmd=()
dryrun=0
flag=0

case $1 in
	--help)
		usage; exit;;
	-n|--dry-run)
		dryrun=1; shift;;
	--?*|-[!-]*)
		echo "${0##*/}: unknown option '$1'" >&2; exit 2;;
esac

if [[ -t 0 ]]; then
	# Find the *last* double-dash arg
	ldash=0
	for (( i=1; i<=$#; i++ )); do
		if [[ ${!i} == "--" ]]; then
			ldash=$i
		fi
	done
	if (( ldash )); then
		cmd=("${@:1:ldash-1}")
		args=("${@:ldash+1}")
	else
		cmd=("${@:1:1}")
		args=("${@:2}")
	fi
else
	for arg; do
		cmd+=("$arg")
	done
fi

if (( ! ${#cmd[@]} )); then
	echo "each: command not specified" >&2
	exit 2
fi

if (( dryrun )); then
	cmd=(Xecho "${cmd[@]}")
fi

# Find the {} placeholder
lpos=0
for (( i=0; i<${#cmd[@]}; i++ )); do
	if [[ ${cmd[i]} == *"{}"* ]]; then
		if (( lpos )); then
			echo "each: only one '{}' is allowed" >&2
			exit 2
		fi
		lpos=$i
		larg=${cmd[lpos]}
	fi
done
if (( !lpos )); then
	# If no placeholder, append arg as the last item
	lpos=${#cmd[@]}
	larg="{}"
fi

# Run with args
if [[ -t 0 ]]; then
	for arg in "${args[@]}"; do
		cmd[lpos]=${larg//"{}"/"$arg"}
		"${cmd[@]}"
	done
else
	while IFS= read -r arg; do
		cmd[lpos]=${larg//"{}"/"$arg"}
		"${cmd[@]}" </dev/tty
	done
fi
