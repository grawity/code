#!/usr/bin/env bash
# notify-resend -- wrapper around notify-send that automatically replaces the
# previous notification from the same program

opt_urgency=
opt_expire=
opt_appname=
opt_icon=
opt_category=
opt_transient=0
opt_hints=()
opt_printid=0
opt_replaceid=

# Handle most notify-send options except --print-id, --wait, and --action
# (conflicts with --print-id stdout usage).
while getopts "a:c:eh:i:pr:t:u:" OPT; do
	case $OPT in
	u) opt_urgency=$OPTARG;;
	t) opt_expire=$OPTARG;;
	a) opt_appname=$OPTARG;;
	i) opt_icon=$OPTARG;;
	c) opt_category=$OPTARG;;
	e) opt_transient=1;;
	h) opt_hints+=("$OPTARG");;
	p) opt_printid=1;;
	r) opt_replaceid=$OPTARG;;
	*) exit 2;;
	esac
done; shift $((OPTIND-1))

args=()
if [[ $opt_urgency ]]; then
	args+=(-u "$opt_urgency")
fi
if [[ $opt_expire ]]; then
	args+=(-t "$opt_expire")
fi
if [[ $opt_appname ]]; then
	args+=(-a "$opt_appname")
fi
if [[ $opt_icon ]]; then
	args+=(-i "$opt_icon")
fi
if [[ $opt_category ]]; then
	args+=(-c "$opt_category")
fi
if (( opt_transient )); then
	args+=(-e)
fi
for hint in "${opt_hints[@]}"; do
	args+=(-h "$hint")
done
if [[ $opt_replaceid ]]; then
	statefile=${XDG_RUNTIME_DIR?}/notify-send.$opt_replaceid
	>> "$statefile"
	replaceid=$(< "$statefile")
	args+=(-r "${replaceid:-0}")
fi
args+=("$@")

replaceid=$(notify-send -p "${args[@]}")

if [[ $opt_replaceid ]]; then
	echo "$replaceid" > "$statefile"
fi
if (( opt_printid )); then
	echo "$replaceid"
fi