#!/usr/bin/env bash

. lib.bash || exit
. libks.bash || exit

is_git() { git rev-parse --git-dir >&/dev/null; }
is_annex() { git rev-parse refs/heads/git-annex >&/dev/null; }
is_annex!() { is_annex || die "not a git-annex repository"; }

set -e

cmd=$1; shift || true

case $cmd in
    setup)
        name=$1
        dir=$PWD/$name
        if [[ ! $name ]]; then
            die "missing name (e.g. Videos)"
        elif [[ -d $dir ]]; then
            die "'$dir' already exists"
        fi
        mkdir "$dir"
        cd "$dir"
        if is_annex; then
            die "'$PWD' is already a git-annex repository"
        elif is_git; then
            die "'$PWD' is already a non-annex Git repository"
        fi
        log "setting up git-annex repository"
        git init
        git annex init
        git annex direct
        log "setting up origin repository"
        rdir="Attic/$name.git"
        if ! ssh virgule "[ -d $rdir ]"; then
            ssh virgule "git init --bare $rdir && cd $rdir && git annex init"
        fi
        log "initial sync"
        git remote add origin "annex:${rdir%.git}"
        git annex sync
        ;;
    link)
        base=$(git config --get nullroute.annex-name \
                || basename "$(git -c core.bare=false rev-parse --show-toplevel)")
        for name; do
            case $name in
                fs1)
                    dir="fs1:/Attic";;
                origin)
                    dir="annex:Attic";;
                vol3)
                    dir="/run/media/grawity/vol3_tombstone/Attic";;
                vol4)
                    dir="/run/media/grawity/vol4_grimoire/Attic";;
                frost|rain)
                    dir="/home/grawity/.$name/Attic";;
                *)
                    err "unknown remote '$name'"; continue;;
            esac
            git remote add "$name" "$dir/$base"
            annex sync "$name"
        done
        annex sync
        ;;
    want-get|missing)
        exec git annex find --want-get --not --in .
        ;;
    want-drop)
        exec git annex find --want-drop --in .
        ;;
    diff)
        is_annex!
        git annex find --want-get --not --in . | sed $'s/.*/\e[;32mwant\e[m &/'
        git annex find --want-drop --in . | sed $'s/.*/\e[;31mdrop\e[m &/'
        ;;
    examine)
        is_annex!
        if (( ! $# )); then
            exec 2>/dev/null
            set -- uuid.log group.log trust.log preferred-content.log
        fi
        for arg; do
            if [[ $arg != */* && $arg != *.* ]]; then
                arg+=".log"
            fi
            if (( $# > 1 )); then
                echo -e "\e[1m--- $arg ---\e[m"
            fi
            git show "git-annex:$arg"
        done
        ;;
    log-format)
        perl -E '
            use List::MoreUtils qw(uniq);
            while (<>) {
                chomp;
                my ($key, $value, $time) = /^(\S+) (.*) timestamp=([0-9.]+)s$/;
                if (!$items{$key}) {
                    push @items, $key;
                    $items{$key} //= [];
                }
                push @{$items{$key}}, [$time, $value, $_];
            }
            for my $key (@items) {
                my @items = uniq
                            grep {/./}
                            map {$_->[1]}
                            sort {$a->[0] <=> $b->[0]}
                            @{$items{$key}};
                my $last = pop @items;
                say "$key";
                say " - $_" for $last;
                say " \e[38;5;242m- $_\e[m" for reverse @items;
            }
        '
        ;;
    hash)
        for f; do
            n=${f##*/}
            e=$(echo "$n" | perl -ne '
                no locale;
                s/[^a-z0-9.]//g;
                @ext = reverse grep {length($_) <= 4} split(/\./);
                print @ext ? join(".", "", reverse @ext[0..1]) : "";
            ')
            s=$(stat -c %s "$f")
            h=$(sha256sum "$f")
            h=${h%% *}
            echo "SHA256E-s$s--$h$e"
        done
        ;;
    inject)
        for f; do
            h=$(annex hash "$f")
            annex setkey "$h" "$f"
        done
        ;;
    addurls|registerurls)
        if (( ! $# )); then
            set -- **/*
        fi
        for f; do
            if [[ -d $f ]]; then
                :
            elif [[ -L $f && ! -e $f ]]; then
                notice "item '$f' is a broken symlink"
            elif [[ ! -f $f ]]; then
                warn "item '$f' is not a file" || true
            else
                u=$(attr -L -q -g xdg.origin.url "$f" 2>/dev/null || true)
                if [[ ! $u ]]; then
                    warn "no origin URL for file '$f'"
                elif [[ $u != @(http|https|ftp)://* ]]; then
                    err "file '$f' has weird origin URL '$u'"
                else
                    annex addurl --file="$f" "$u"
                fi || continue
            fi
        done
        ;;
    commit|ci)
        annex sync --no-pull --no-push
        ;;
    dupes)
        find "$(git rev-parse --git-dir)/annex/objects" \
            -type f -name "*.map" \
            -exec wc -l {} \; \
            | awk '$1 > 1 {print $2}' \
            | xargs -n 1 cat
        ;;
    put)
        annex copy --in . --not --in "$1" "${@:2}" --to "$1"
        ;;
    # overrides
    addurl)
        if (( $# == 2 )) && [[ -f $1 || -L $1 ]]; then
            set -- --file="$1" "$2"
        elif (( $# == 1 )); then
            set -- --file="$(urlencode -dS "${1##*/}")" "$1"
        fi
        ;;&
    get)
        # for convenience when copypasting symlinks
        args=()
        for arg in "$@"; do
            if [[ -L ${arg%@} ]]; then
                arg=${arg%@}
            fi
            args+=("$arg")
        done
        set -- "${args[@]}"
        # use -J2 by default
        jobs=0
        for arg in "$@"; do
            if [[ $arg == -J?* ]]; then
                jobs=${arg#-J}
            fi
        done
        if (( ! jobs )); then
            set -- -J2 "$@"
        fi
        ;;&
    info)
        if (( ! $# )); then
            set -- --fast
        elif [[ $* == @(-v|--slow) ]]; then
            set --
        fi
        ;;&
    *)
        if [[ $cmd ]]; then
            set -- "$cmd" "$@"
        fi
        exec git annex "$@"
        ;;
esac

# vim: ts=4:sw=4:et
