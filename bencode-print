#!/usr/bin/env perl
use warnings;
use strict;
use Convert::Bencode qw(bencode bdecode);
use List::Util qw(min);
use JSON;

my $indent = "  ";

sub is_printable {
	my ($str) = @_;

	return ($str !~ /[\x00-\x1F]/);
}

sub dump_str {
	my ($str, @path) = @_;
	my $depth = @path;

	if (is_printable($str)) {
		print "\"".$str."\"";
	} else {
		my @bytes = map {sprintf("%02x", $_)} unpack("C*", $str);
		my $len = 24;
		print "bytes [";
		if (@bytes > $len) {
			my $i = 0;
			my $n = @bytes;
			print "\n";
			while ($i < $n) {
				print $indent x ($depth+1);
				printf "[%08x] ", $i;
				print join(" ", @bytes[$i..min($i+$len, $n)-1]);
				print "\n";
				$i += $len;
			}
			print $indent x $depth;
		} else {
			print join(" ", @bytes);
		}
		print "]";
	}
}

sub dump_rec {
	my ($data, @path) = @_;
	my $depth = @path;

	if ($ENV{DEBUG}) {
		print "\e[33m<$depth: ".join(", ", map {"'$_'"} @path)."> \e[m";
	}

	if (ref $data eq "HASH") {
		print "{\n";
		for my $key (sort keys %$data) {
			print $indent x ($depth+1);
			dump_str($key, (@path));
			print ": ";
			dump_rec($data->{$key}, (@path, $key));
		}
		print $indent x $depth;
		print "}\n";
	}
	elsif (ref $data eq "ARRAY") {
		print "[\n";
		for my $item (@$data) {
			print $indent x ($depth+1);
			dump_rec($item, (@path, "[]"));
		}
		print $indent x $depth;
		print "]\n";
	}
	else {
		dump_str($data, (@path));
		print "\n";
	}
}

my $benc = do { local $/; <STDIN>; };
my $data = bdecode($benc);

dump_rec($data);
