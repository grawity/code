#!/usr/bin/env perl
use warnings;
use strict;
use Data::Dumper;
use File::Basename;

my %dir_locs;
my %file_locs;
my @remote_name;
my %remote_use;

sub remote_color {
	my ($remote) = @_;
	for ($remote) {
		return  -3 if /^here$/;
		return  82 if /^rain$/;
		return 109 if /^frost$/;
		return -13 if /^vol4$/;
		return  13 if /^vol\d+/;
		return  12 if /^fs\d+/;
		return   4 if /^ukvirt\d+/;
		return  15;
	}
}

sub remote_hidden {
	my ($remote) = @_;
	return ($remote =~ /^(bittorrent|web)$/);
}

sub fmt {
	my ($str, $fmt) = @_;
	return (length($str) && length($fmt))
		? "\e[".$fmt."m".$str."\e[m"
		: $str;
}

sub fg {
	my ($str, $color) = @_;
	if ($color < 0) {
		$str = fmt($str, "1");
	}
	return fmt($str, "38;5;".abs($color));
}

sub fmt_remotes {
	my (@remotes) = @_;
	return fg("{", 8).join(" ", @remotes).fg("}", 8);
}

sub present {
	my ($loc, $idx) = @_;
	return 0 if $idx >= length($loc);
	return 0 if remote_hidden($remote_name[$idx]);
	return (substr($loc, $idx, 1) ne "_");
}

sub diff_locsets {
	my ($a, $b) = @_;

	my @a_only = grep {
		present($a, $_) && !present($b, $_)
	} 0..length($a);

	my @b_only = grep {
		present($b, $_) && !present($a, $_)
	} 0..length($b);

	return ((map {$_ => "-"} @a_only),
		(map {$_ => "+"} @b_only));
}

sub locset_str {
	my ($loc) = @_;

	my @remotes = map {
		my $name = $remote_name[$_];
		my $present = present($loc, $_);
		fg($name, $present ? remote_color($name) : 8)
	} grep {
		$remote_use{$_}
	} sort {
		$remote_name[$a] cmp $remote_name[$b]
	} 0..$#remote_name;

	return fmt_remotes(@remotes);
}

sub locset_diffstr {
	my ($loc1, $loc2) = @_;

	my %diff = diff_locsets($loc1, $loc2);
	my @remotes = map {
		my $name = $remote_name[$_];
		my $present = $diff{$_};
		$present . fg($name, $present eq "+" ? remote_color($name) : 8)
	} grep {
		$diff{$_}
	} sort {
		$remote_name[$a] cmp $remote_name[$b]
	} 0..$#remote_name;

	return if !@remotes;
	return fmt_remotes(@remotes);
}

while (<STDIN>) {
	if (/^([_Xx]+) (.+)$/) {
		my $loc = $1;
		my $dir = dirname($2);
		my $base = basename($2);
		$dir_locs{$dir}{$loc} += 1;
		$file_locs{$dir}{$base} = $loc;
		for (my $i = 0; $i < length($loc); $i++) {
			if (present($loc, $i)) {
				$remote_use{$i}++;
			}
		}
	}
	elsif (/^(\|*)([^|_Xx].*?)$/) {
		my $pos = length($1);
		my $name = $2;
		$name =~ s/ \(untrusted\)$//;
		$remote_name[$pos] = $name;
	}
	else {
		warn "!! unrecognized line:$.: $_\n";
	}
}

my @dirs = sort keys %dir_locs;

for my $dir (@dirs) {
	my %locs = %{$dir_locs{$dir}};
	my @locs = sort {$locs{$a} <=> $locs{$b}} keys %locs;
	my $main = pop @locs;
	print locset_str($main)." $dir/\n";
	if (@locs) {
		my $full = ($locs{$main} - $locs{$locs[-1]} <= 2);
		my %files = %{$file_locs{$dir}};
		my @files = sort grep {$full || $files{$_} ne $main} keys %files;
		for (@files) {
			my $loc_str = $full
				? locset_str($files{$_})
				: locset_diffstr($main, $files{$_});
			next if !$loc_str;
			my $name_fmt = $full ? "" : "1";
			print "  ".$loc_str." ".fmt("$_", $name_fmt)."\n";
		}
	}
}
