#!/usr/bin/env bash
# git-up - fast-forward the latest changes from upstream

set -e

if [ "$1" ]; then
	cd "$1" || exit
	shift
fi

opts=$(git config --get-all nullroute.git-new.options || true)
paths=$(git config --get-all nullroute.git-new.paths || true)

old=$(git rev-parse "HEAD")

if [ "$(git rev-parse --is-bare-repository)" = "true" ]; then
	git fetch
else
	git pull --ff-only --no-stat "$@"

	if [ -e ".git/refs/remotes/origin/main" ]; then
		if [ "$(< .git/HEAD)" = "ref: refs/heads/master" ]; then
			echo "looks loke master branch was renamed, following"
			git reset --keep HEAD^ &&
			git branch -m main &&
			git branch -u origin/main &&
			git remote set-head origin main &&
			git pull --ff-only --no-stat "$@"
		fi
	fi
fi

new=$(git rev-parse "HEAD")

if [ "$new" != "$old" ]; then
	settitle "git up [${PWD/#"$HOME/"/"~/"}]"
	# Reflogs are't always available in bare repositories; I'd be
	# using "@{1}.." otherwise. Although maybe this is more readable.
	tig $opts "$old..$new" -- $paths
fi
