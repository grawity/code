#!/usr/bin/env bash

. lib.bash || exit

if (( $# )); then
	dirs=("$@")
else
	dirs=(.)
fi

for dir in "${dirs[@]}"; do
	(
		base=$(git -C "$dir" rev-parse --show-toplevel)
		src=$(git -C "$dir" rev-parse --git-dir)
		src=$(cd "$dir" && realpath "$src")
		dst="$base.git"

		log "repository '$base'"
		log "gitdir '$src'"

		if [[ "$(git -C "$dir" config core.bare)" == "true" ]]; then
			notice "'$dir' is already a bare repo"
			continue
		fi

		mv -v "$src" "$dst"

		git -C "$dst" update-ref -d --no-deref "refs/remotes/origin/HEAD"
		git -C "$dst" push . "+refs/remotes/origin/*:refs/heads/*"
		git -C "$dst" pack-refs --all --prune

		mkdir -p "$dst/logs/refs/heads"
		mv "$dst/logs/refs/remotes/origin/"* "$dst/logs/refs/heads/"

		git -C "$dst" config core.bare true
		git -C "$dst" config --unset-all remote.origin.fetch
		git -C "$dst" config remote.origin.fetch "+refs/heads/*:refs/heads/*"
		git -C "$dst" config remote.origin.mirror true
		git -C "$dst" config --list --local |
			grep -o '^branch\.[^.]*' |
			sort -u |
			while read -r line; do
				git -C "$dst" config --remove-section "$line"
			done

		log "fetching from remote"
		git -C "$dst" fetch origin

		git -C "$dst" for-each-ref |
			while read -r _ _ ref; do
				if [[ $ref == refs/remotes/* ]]; then
					git -C "$dst" update-ref -d "$ref"
				fi
			done
		git -C "$dst" gc
		git -C "$dst" prune

		rm -f "$dst"/index
		rm -f "$dst"/{COMMIT_EDITMSG,FETCH_HEAD,ORIG_HEAD}
		rdempty --quiet "$dst"

		log "deleting old worktree"
		find "$base" -print -delete | progress

		log "moved to '$dst'"
	) \
	|| err "conversion of '$dir' failed"
done

lib::exit
