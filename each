#!/usr/bin/env bash
# each -- reverse xargs
#
# Syntax not set in stone yet. Should probably be called 'map'.
#
# Usage 1:
#
#   - for x in one two three; do frob "$x"; done
#   + each frob -- one two three
#
# Usage 2:
#
#   - find ./foo/ | xargs -I -d '\n' frob {}
#   - find ./foo/ | xargs -i frob {}
#   + find ./foo/ | each frob

usage() {
	echo "Usage: ${0##*/} <command> -- <args>"
	echo "       <input> | ${0##*/} <command>"
}

case $1 in
	--help)
		usage; exit;;
	--?*|-[!-]*)
		echo "${0##*/}: unknown option '$1'" >&2; exit 2;;
esac

args=()
cmd=()
flag=0

if [[ -t 0 ]]; then
	# Find the *last* double-dash arg
	ldash=0
	for (( i=1; i<=$#; i++ )); do
		if [[ ${!i} == "--" ]]; then
			ldash=$i
		fi
	done
	if (( !ldash )); then
		echo "each: args must be specified" >&2
		exit 2
	fi

	# Collect "cmd -- args"
	for (( i=1; i<=$#; i++ )); do
		if (( i < ldash )); then
			cmd+=("${!i}")
		elif (( i == ldash )); then
			continue
		else
			args+=("${!i}")
		fi
	done
else
	for arg; do
		cmd+=("$arg")
	done
fi

# Find the {} placeholder
lpos=0
for (( i=0; i<${#cmd[@]}; i++ )); do
	if [[ ${cmd[i]} == "{}" ]]; then
		if (( lpos )); then
			echo "each: only one '{}' is allowed" >&2
			exit 2
		fi
		lpos=$i
	fi
done
if (( !lpos )); then
	# If no placeholder, append arg as the last item
	lpos=${#cmd[@]}
fi

# Run with args
if [[ -t 0 ]]; then
	for arg in "${args[@]}"; do
		cmd[lpos]=$arg; "${cmd[@]}"
	done
else
	while IFS= read -r arg; do
		cmd[lpos]=$arg; "${cmd[@]}" </dev/tty
	done
fi
