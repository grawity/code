#!/usr/bin/env bash

. lib.bash || exit
. libks.bash || exit

is_git() { git rev-parse --git-dir >&/dev/null; }
is_annex() { git rev-parse refs/heads/git-annex >&/dev/null; }
is_annex!() { is_annex || die "not a git-annex repository"; }

set -e

case $1 in
    setup)
        name=$2
        [[ $name ]] || die "missing name (e.g. Videos)"
        [[ $name != */* ]] || die "name must not contain '/'"
        [[ $name == *.git ]] || name+=".git"
        # set up local git-annex repository
        if is_annex; then
            notice "'$PWD' is already a git-annex repository"
        elif is_git; then
            die "'$PWD' is already a non-annex Git repository"
        else
            log "creating a git-annex repository"
            git init
            git annex init
            git annex direct
        fi
        # set up the remote metadata repo
        if u=$(git config remote.origin.url); then
            notice "origin is already set up as '$u'"
        else
            log "creating metadata repository"
            repo="pub/git/~grawity/annex/$name"
            ssh virgule "test -d $repo || git init --bare $repo"
            log "adding origin remote"
            #git remote add origin "nullroute+ssh:$name"
            git remote add origin "nullroute+annex:$name"
        fi
        git config remote.origin.annex-ignore true
        # sync
        log "performing initial sync"
        git annex sync
        ;;
    want-get|missing)
        exec git annex find --want-get --not --in .
        ;;
    want-drop)
        exec git annex find --want-drop --in .
        ;;
    diff)
        is_annex!
        git annex find --want-get --not --in . | sed $'s/.*/\e[;32mwant\e[m &/'
        git annex find --want-drop --in . | sed $'s/.*/\e[;31mdrop\e[m &/'
        ;;
    examine)
        is_annex!
        shift
        if (( ! $# )); then
            exec 2>/dev/null
            set -- uuid.log group.log trust.log preferred-content.log
        fi
        for arg; do
            if [[ $arg != */* && $arg != *.* ]]; then
                arg+=".log"
            fi
            if (( $# > 1 )); then
                echo -e "\e[1m--- $arg ---\e[m"
            fi
            git show "git-annex:$arg"
        done
        ;;
    log-format)
        perl -E '
            use List::MoreUtils qw(uniq);
            while (<>) {
                chomp;
                my ($key, $value, $time) = /^(\S+) (.*) timestamp=([0-9.]+)s$/;
                if (!$items{$key}) {
                    push @items, $key;
                    $items{$key} //= [];
                }
                push @{$items{$key}}, [$time, $value, $_];
            }
            for my $key (@items) {
                my @items = uniq
                            grep {/./}
                            map {$_->[1]}
                            sort {$a->[0] <=> $b->[0]}
                            @{$items{$key}};
                my $last = pop @items;
                say "$key";
                say " - $_" for $last;
                say " \e[38;5;242m- $_\e[m" for reverse @items;
            }
        '
        ;;
    untracked)
        comm -13 <(git annex find | sort) <(find \( -name .git -prune \) -o \( -type f -print \) | sed 's:^\./::' | sort)
        ;;
    *)
        exec git annex "$@"
        ;;
esac

# vim: ts=4:sw=4:et
