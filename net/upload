#!/usr/bin/env bash

. lib.bash || exit
. libks.bash || exit

usage() {
	echo "Usage: $progname [options] <file>…"
	echo #|---'---|---'---|
	echo "  -0            do not use yearly subdirectories"
	echo "  -1            upload to fs1 instead of main site"
	echo "  -c            continue upload / overwrite file"
	echo "  -d path       create a subdirectory"
	echo "  -S regex      mangle (sed) the destination filename"
	echo "  -t            add timestamps to destination filenames"
	echo "  -X            delete files instead of uploading"
}

r:test() {
	local test=$1 host=${2%%:*} path=${2#*:}
	ks:sshrun "$host" test $test "$path"
}

r:mkdir() {
	local host=${1%%:*} path=${1#*:}
	ks:sshrun "$host" mkdir -p "$path"
}

r:rm_rvf() {
	local host=${1%%:*} path=${1#*:}
	ks:sshrun "$host" rm -rvf "$path"
}

declare -- conf="$path_config/upload.conf"
declare -A fsbase urlbase

fsbase="virgule:nullroute/tmp"
urlbase="https://nullroute.eu.org/tmp"

fsbase[fs1]="ukradius:pub/fs1/tmp"
urlbase[fs1]="https://fs1.nullroute.eu.org/tmp"

if [[ -e $conf ]]; then
	. "$conf" || die "could not load configuration from '$conf'"
fi

# parse command line

declare -i arg_clobber=0
declare -- arg_mangle=
declare -i arg_remove=0
declare -- arg_server=
declare -- arg_subdir=
declare -i arg_timestamp=0
declare -i arg_yearly=1

while getopts ":01cd:S:tX" OPT; do
	case $OPT in
	0) arg_yearly=0;;
	1) arg_server=fs1;;
	c) arg_clobber=1;;
	d) arg_subdir=$OPTARG;;
	S) arg_mangle=$OPTARG;;
	t) arg_timestamp+=1;;
	X) arg_remove=1;;
	*) die_getopts;;
	esac
done; shift $((OPTIND-1))

if [[ $arg_server ]]; then
	fsbase=${fsbase[$arg_server]}
	urlbase=${urlbase[$arg_server]}
	if [[ $fsbase && $urlbase ]]; then
		trace "uploading to '$fsbase'"
	else
		die "unknown server '$arg_server'"
	fi
fi

if (( arg_yearly )); then
	year=$(date +%Y)
	fsbase+="/$year"
	urlbase+="/$year"
fi

if [[ $arg_subdir ]]; then
	fsbase+="/$arg_subdir"
	urlbase+="/$arg_subdir"
fi

debug "base dir: '$fsbase'"
debug "base url: '$urlbase'"

if (( arg_timestamp > 2 )); then
	timefmt='%Y%m%d.%H%M%S.'
elif (( arg_timestamp > 1 )); then
	timefmt='%s.'
elif (( arg_timestamp > 0 )); then
	timefmt='%Y%m%d.'
fi

# prepare upload target

if [[ $arg_server || $arg_subdir ]]; then
	# $arg_server is a hack, until I copy rotate-up.sh to all other servers
	r:mkdir "$fsbase"
fi

# upload files

clip=()

if (( !$# )); then
	die "missing file names"
fi

for arg; do
	if (( ! arg_remove )); then
		if [[ ! -f $arg ]]; then
			err "'$arg' is not a file"
			continue
		elif [[ ! -s $arg ]]; then
			warn "'$arg' is empty, skipping"
			continue
		fi
	fi

	name=${arg##*/}
	# yay special case
	if [[ $name == Screencast?from* ]]; then
		name=$(echo "$name" | sed -r "s/^Screencast from //; s/ /./g; s/://g")
	fi
	if [[ $arg_mangle ]]; then
		name=$(echo "$name" | sed -r "$arg_mangle")
	fi
	if (( arg_timestamp )); then
		name=$(date +"$timefmt")$name
	fi
	source=$(readlink -f "$arg")
	target="$fsbase/$name"
	url="$urlbase/$name"
	debug "* source: '$source'"
	debug "  target: '$target'"
	debug "  url: '$url'"

	if [[ -e $source ]]; then
		stored_target=$(ks:getattr "$source" upload.path)
		stored_url=$(ks:getattr "$source" upload.url)

		if [[ $stored_url == "$urlbase"/* ]]; then
			debug "found stored URL at default base, remembering"
			debug "* stored target: '$stored_target'"
			stored_name=${stored_url#"$urlbase"/}
			stored_target="$fsbase/$stored_name"
			debug "  adjust target: '$stored_target'"
			debug "  stored url: '$stored_url'"
		fi
	fi

	if (( arg_remove )); then
		if [[ $stored_target ]]; then
			debug "removing based on stored target"
			r:rm_rvf "$stored_target"
			ks:delattr "$source" upload.path
			ks:delattr "$source" upload.url
		else
			debug "removing based on guessed target"
			r:rm_rvf "$target"
		fi
	else
		if r:test -s "$target" && ! (( arg_clobber )); then
			notice "'$name' already exists on server"
		else
			rsync -Ps "$source" "$target"
			ks:setattr "$source" upload.path "$target"
			ks:setattr "$source" upload.url "$url"
		fi

		echo "$name → $url"
		clip+=("$url")
	fi
done

if [[ "$DISPLAY" ]] && (( ${#clip[@]} )); then
	echo -n "${clip[*]}" | xsel -i -b
fi

(( !errors ))
