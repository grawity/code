#!/usr/bin/env bash
# ssh-authz-update - authorized_keys updater tool

PATH="$HOME/bin:$HOME/code/bin:$PATH"

. lib.bash || exit
. libfilterfile.bash || exit
. libhttpfetch.bash || exit

progname_prefix=0

usage() {
	echo "Usage: $progname [-k URI] [-rv]"
	echo ""
	echo "  -k URI    use another keyserver"
	echo "  -r        receive signing key"
	echo "  -v        verbose"
	echo ""
	echo -e "\e[1mWARNING: This script will replace your keys with grawity's!\e[m"
}

recv_key() {
	local key=$1 status=
	debug "retrieving key '$key'"
	if status=$($GPG --keyserver "$keyserver" --recv-key "$key" 2>&1); then
		trace "$status"
	else
		echo "$status" >&2
		warn "failed to receive key $key from $keyserver"
		return 1
	fi
}

fetch() {
	local url=$1 out=$2
	local max_tries=3 retry_wait=3 attempt=1
	while true; do
		debug "fetching $url (#$attempt)"
		if http_fetch "$url" "$out"; then
			return 0
		elif (( $? == 99 )); then
			break
		fi
		rm -f "$out"
		if (( attempt++ >= max_tries )); then
			break
		fi
		sleep $retry_wait
		(( retry_wait *= 2 ))
	done
	return 1
}

verify() {
	local input=$1 output=$2 status= errors=0
	debug "verifying '$input' to '$output'"
	if status=$($GPG --batch --yes --status-fd 1 --output "$output" \
	                 --trust-model pgp --decrypt "$input" 2> /dev/null); then
		if ! egrep -qs "^\\[GNUPG:\\] VALIDSIG $signer_fpr " <<< "$status"; then
			err "file has invalid signature"
		fi
		if ! egrep -qs "^\\[GNUPG:\\] TRUST_ULTIMATE( 0 .+)?\$" <<< "$status"; then
			err "signer's key is not ultimately trusted"
		fi
		if (( errors )); then
			echo "$status" >&2
			return 1
		else
			trace "$status"
			return 0
		fi
	else
		err "unknown GnuPG error occured"
		echo "$status" >&2
		return 1
	fi
}

readonly src_url="http://nullroute.eu.org/~grawity/files/authorized_keys.txt"
readonly dst_file="$HOME/.ssh/authorized_keys"
readonly signer_fpr="2357E10CEF4F7ED27E233AD5D24F6CB2C1B52632"

import_key=0
keyserver="hkps://keyserver.ubuntu.com"

while getopts ":kr" OPT; do
	case $OPT in
	k) keyserver=$OPTARG;;
	r) import_key=1;;
	*) lib::die_getopts;;
	esac
done

umask 077

if [[ -e ~/.ssh/authorized_keys.optout ]]; then
	die "found opt-out marker"
fi

# find the tool

if have gpg2; then
	GPG=gpg2
elif have gpg; then
	GPG=gpg
else
	die "'gpg' not found in \$PATH"
fi

# ensure key exists in keyring

if (( import_key )); then
	recv_key "$signer_fpr" || die "failed to import key '$signer_fpr'"
	log "imported owner's key into keyring"
	if confirm "mark this key as ultimately trusted?"; then
		(echo "$signer_fpr:6:" | $GPG --import-ownertrust) &&
		log "key's ownertrust updated"
	else
		die "only ultimately trusted keys are accepted"
	fi
elif ! $GPG --list-keys "$signer_fpr" > /dev/null; then
	die "key $signer_fpr not found in keyring"
fi

# download new pubkeys

mkdir -p "${dst_file%/*}"

tmp_signed=$(mktemp "$file.XXXXXXXX")

if ! fetch "$src_url" "$tmp_signed"; then
	rm -f "$tmp_signed"
	die "fetch of $src_url failed"
elif ! test -s "$tmp_signed"; then
	rm -f "$tmp_signed"
	die "empty file fetched from $src_url"
fi

tmp_plain=$(mktemp "$file.XXXXXXXX")

if ! verify "$tmp_signed" "$tmp_plain"; then
	rm -f "$tmp_plain"
	die "verification of $tmp_signed failed"
fi

{ echo "# updated: at $(date +"%Y-%m-%d %H:%M:%S %z")"
  echo "# updated: from $src_url"
  cat "$tmp_plain"
  if [ -s "$file.local" ]; then
	echo "# updated: from $file.local"
	cat "$file.local"
  fi
  echo "# updated: end"
} > "$dst_file"

rm -f "$tmp_plain" "$tmp_signed"

if [[ -t 1 ]]; then
	num=$(grep -c '^[^#]' "$dst_file")
	log "imported $num authorized keys"
fi
