#!/usr/bin/env bash
# listpull -- helper for devel/pull to parse the 'Pullfile'

. lib.bash || exit

startdir=$PWD
filename=Pullfile

while getopts : OPT; do
	case $OPT in
	*) lib:die_getopts;;
	esac
done; shift $((OPTIND-1))

if (( ! $# )); then
	if [[ -s $filename ]]; then
		# XXX: In original devel/pull we used to deliberately permit
		# glob expansion so that a Pullfile could have '*/' to indicate
		# "the rest" after prioritizing some specific paths.
		#set -f
		set -- $(grep "^[^#]" "$filename")
		#set +f
	elif [[ -f $filename ]]; then
		set -- */
	else
		set -- .
	fi
fi

_skip_glob=""
skip_glob=""
declare -A seen=()

for arg; do
	case $arg in
	-*)
		arg=${arg#-}
		if [[ $arg == *[*?]* ]]; then
			warn "use '!$arg', not '-$arg', to exclude globs"
		fi
		if [[ ! -d $arg ]]; then
			debug "exclusion '$arg' is not a directory, ignoring"
			continue
		fi
		dir=$(readlink -f "$arg")
		debug "excluding dir '$dir'"
		seen[$dir]=y
		continue
		;;
	!*)
		arg=${arg#!}
		debug "excluding glob '$arg'"
		_skip_glob+="|$arg"
		skip_glob="@(${_skip_glob#|})"
		debug "skip_glob is now '$skip_glob'"
		continue
		;;
	esac

	if [[ $skip_glob && $arg == $skip_glob ]]; then
		debug "arg '$arg' is excluded, skipping"
		continue
	fi

	if [[ ! -d $arg && -d $arg.git && ! ${seen["$arg"]} ]]; then
		arg+=.git
	fi
	if [[ ! -d $arg ]]; then
		err "not a directory: '$arg'"
		continue
	fi

	dir=$(readlink -f "$arg")
	if [[ ${seen[$dir]} ]]; then
		debug "- dir '$dir' already seen, skipping"
		continue
	fi
	seen[$dir]=y
	if [[ -u $dir ]]; then
		debug "- dir '$dir' is ignored (+u), skipping"
		continue
	fi
	echo "$arg"
done
