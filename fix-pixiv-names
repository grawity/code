#!/usr/bin/env python3
import argparse
import bs4
from functools import lru_cache
from nullroute.core import Core, Env
from nullroute.misc import filter_filename, set_file_attrs
from nullroute.api.pixiv import PixivClient
import os
from pprint import pprint
import re
from requests.exceptions import HTTPError

# TODO: https://danbooru.donmai.us/wiki_pages/58938
# TODO: https://github.com/r888888888/danbooru/issues/2383

class PixivApi(PixivClient):
    MEMBER_URL = "http://www.pixiv.net/member.php?id=%s"
    ILLUST_URL = "http://www.pixiv.net/member_illust.php?mode=%s&illust_id=%s"

    def __init__(self):
        super().__init__()
        self._authenticate()

        self.member_name_map = {}
        try:
            _map_path = Env.find_config_file("pixiv_member_names.txt")
            Core.debug("loading member aliases from %r", _map_path)
            with open(_map_path, "r") as fh:
                for line in fh:
                    if line.startswith(";"):
                        continue
                    k, v = line.split("=")
                    k = int(k.strip())
                    v = v.strip()
                    self.member_name_map[k] = v
        except FileNotFoundError:
            pass

    def fmt_member_tag(self, member_id, member_name):
        member_name = self.member_name_map.get(member_id, member_name)
        member_name = member_name.replace(" ", "_")
        member_name = re.sub("(@|＠).*", "", member_name)
        member_name = re.sub(r"[◆|_]?[0-9一三]日.+?[0-9]+[a-z]*", "", member_name)
        return "%s_pixiv%s" % (member_name, member_id)

    def fmt_member_url(self, member_id):
        return self.MEMBER_URL % (member_id,)

    def fmt_illust_url(self, illust_id, mode="medium"):
        return self.ILLUST_URL % (mode, illust_id)

    ## fallback HTML scrape functions

    @lru_cache(maxsize=1024)
    def scrape_member_name_by_member_id(self, member_id):
        url = self.fmt_member_url(member_id)
        Core.info("fetching %s" % url)
        resp = self.ua.get(url)
        resp.raise_for_status()
        body = bs4.BeautifulSoup(resp.content, "lxml")
        name = body.find("h1", {"class": "name"})
        if name:
            return name.get_text()
        raise ValueError("could not find member name tag")

    def scrape_member_id_by_illust_id(self, illust_id):
        url = self.fmt_illust_url(illust_id)
        Core.info("fetching %s" % url)
        resp = self.ua.get(url)
        resp.raise_for_status()
        m = re.search(r'"/?member\.php\?id=(\d+)"',
                      resp.content.decode("utf-8"))
        if m:
            return int(m.group(1))
        raise ValueError("could not find member ID tag")

    ## normal JSON API functions

    @lru_cache(maxsize=1024)
    def get_illust_info(self, illust_id):
        resp = self.api.works(illust_id)
        if resp["status"] == "success":
            return resp["response"][0]
        else:
            raise ValueError("API call failed: %r" % resp)

    @lru_cache(maxsize=1024)
    def get_member_info(self, member_id):
        resp = self.api.users(member_id)
        if resp["status"] == "success":
            return resp["response"][0]
        else:
            raise ValueError("API call failed: %r" % resp)

    ## public interface functions

    @lru_cache(maxsize=1024)
    def get_prefix_by_member_id(self, member_id):
        resp = self.get_member_info(member_id)
        prefix = self.fmt_member_tag(resp["id"], resp["name"])
        return filter_filename(prefix)

    @lru_cache(maxsize=1024)
    def get_prefix_by_illust_id(self, illust_id):
        try:
            resp = self.get_illust_info(illust_id)
            prefix = self.fmt_member_tag(resp["user"]["id"], resp["user"]["name"])
            return filter_filename(prefix)
        except ValueError as e:
            Core.err(str(e))
            member_id = self.scrape_member_id_by_illust_id(illust_id)
            member_name = self.scrape_member_name_by_member_id(member_id)
            prefix = self.fmt_member_tag(member_id, member_name)
            return filter_filename(prefix)

def rename_file_in_dir(dirpath, filename):
    global args
    global bare_re
    global prefix_re
    global suffix_re
    global pixiv_api

    fmt_found = "\033[38;5;10m%s\033[m"
    fmt_notfound = "\033[38;5;9m%s\033[m"

    if re.search(r'_pixiv\d+', filename):
        Core.debug("skip %r: found '_pixiv' in name", filename)
        return

    m = bare_re.match(filename)
    if m:
        Core.debug("process %r: matched bare regex, groups %r", filename, m.groups())
        old_path = os.path.join(dirpath, filename)
        print(old_path, end=" ", flush=True)

        illust_id = int(m.group(1))
        try:
            prefix = pixiv_api.get_prefix_by_illust_id(illust_id)
        except HTTPError as e:
            print(fmt_notfound % "failed")
            Core.err(str(e))
            return

        filename = prefix + " " + filename
        new_path = os.path.join(dirpath, filename)
        print("=>", fmt_found % filename)
        if not args.dry_run:
            os.rename(old_path, new_path)
        return

    m = prefix_re.match(filename)
    if m:
        Core.debug("process %r: matched prefix regex, groups %r", filename, m.groups())
        old_path = os.path.join(dirpath, filename)
        print(old_path, end=" ", flush=True)

        member_id = int(m.group(1))
        try:
            prefix = pixiv_api.get_prefix_by_member_id(member_id)
        except HTTPError as e:
            print(fmt_notfound % "failed")
            Core.err(str(e))
            return

        filename = prefix + " " + m.group(2)
        new_path = os.path.join(dirpath, filename)
        print("=>", fmt_found % filename)
        if not args.dry_run:
            os.rename(old_path, new_path)
        return

    m = suffix_re.match(filename)
    if m:
        Core.debug("process %r: matched suffix regex, groups %r", filename, m.groups())
        old_path = os.path.join(dirpath, filename)
        print(old_path, end=" ", flush=True)

        illust_id = int(m.group(2))
        try:
            prefix = pixiv_api.get_prefix_by_illust_id(illust_id)
        except HTTPError as e:
            print(fmt_notfound % "failed")
            Core.err(str(e))
            return

        filename = m.group(1) + " " + prefix + " " + m.group(2) + m.group(3)
        new_path = os.path.join(dirpath, filename)
        print("=>", fmt_found % filename)
        if not args.dry_run:
            os.rename(old_path, new_path)
        return

    Core.trace("skip %r: not matched", filename)

def fixup_metadata(path):
    global bare_re
    global prefix_re
    global pixiv_api

    filename = os.path.basename(path)
    m = bare_re.match(filename)
    if m:
        illust_id = int(m.group(1))
    else:
        m = prefix_re.match(filename)
        print(m)
        if m:
            illust_id = int(m.group(2))
        else:
            return

    work = pixiv_api.get_illust_info(illust_id)
    attrs = {
        "dublincore.title": work.title,
        "dublincore.creator": "%s_pixiv%s" % (work.user.name, work.user.id),
    }
    set_file_attrs(filename, attrs)

parser = argparse.ArgumentParser()
parser.add_argument("path", nargs=argparse.ZERO_OR_MORE)
parser.add_argument("-n", "--dry-run", action="store_true", help="Do nothing.")
args = parser.parse_args()

bare_re = re.compile(r'^(\d+)(?:_big)?_p\d+(?: \(\d+\))?\.\w+$')
prefix_re = re.compile(r'^pixiv(\d+) (.+)$')
suffix_re = re.compile(r'(.+) (\d+)(_p\d+(?: \(\d+\))?\.\w+)$')
pixiv_api = PixivApi()

for arg in args.path or ["."]:
    if not os.path.exists(arg):
        Core.err("path %r does not exist" % arg)
    if os.path.isdir(arg):
        for dirpath, dirnames, filenames in os.walk(arg):
            for filename in filenames:
                rename_file_in_dir(dirpath, filename)
    else:
        dirpath, filename = os.path.split(arg)
        fixup_metadata(arg)
        rename_file_in_dir(dirpath, filename)

Core.exit()
