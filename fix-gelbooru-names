#!/usr/bin/env python3
import argparse
import bs4
from collections import defaultdict
from nullroute.core import *
from nullroute.misc import filter_filename, uniq
import lxml.etree
from pprint import pprint
import re
import requests

class TagFilter(object):
    def __init__(self):
        self.blacklist = []
        self.translate = []

    @classmethod
    def load_config(self, file_name):
        new = self()
        try:
            with open(Env.find_config_file(file_name)) as fh:
                for line in fh:
                    if " -> " in line:
                        a, b = line.strip().split(" -> ")
                        new.translate.append([re.compile(a, re.I), b])
                    else:
                        a = line.strip()
                        new.blacklist.append(re.compile(a, re.I))
        except FileNotFoundError:
            pass
        return new

    def filter(self, tags):
        tags = [filter_filename(tag) for tag in tags]
        for item in self.blacklist:
            tags = [tag for tag in tags if not item.fullmatch(tag)]
        for xmatch, xto in self.translate:
            tags = [xto if xmatch.fullmatch(tag) else tag for tag in tags]
        return tags

class GelbooruError(Exception):
    pass

class GelbooruApi(object):
    URL = "http://gelbooru.com/index.php"

    def __init__(self):
        self.ua = requests.Session()

    def find_posts(self, tags, limit=100):
        args = {"page": "dapi",
                "s": "post",
                "q": "index",
                "tags": tags,
                "limit": limit}
        r = self.ua.get(self.URL, params=args)
        posts_t = lxml.etree.XML(r.content)
        for post_t in posts_t:
            if post_t.tag == "post":
                yield post_t.attrib

    def scrape_post_info(self, post_id):
        args = {"page": "post",
                "s": "view",
                "id": post_id}
        r = self.ua.get(self.URL, params=args)
        page_t = bs4.BeautifulSoup(r.content, "lxml")
        sidebar_t = page_t.find("ul", {"id": "tag-sidebar"})
        post = {"id": post_id,
                "tags": defaultdict(set)}
        for tag_li_t in sidebar_t.find_all("li"):
            tag_type = tag_li_t["class"][0]
            assert(tag_type.startswith("tag-type-"))
            tag_type = tag_type[len("tag-type-"):]
            tag_link_t = tag_li_t.find_all("a")[-1]
            tag_value = tag_link_t.get_text()
            post["tags"][tag_type].add(tag_value)
        return post

    def get_tags_by_id(self, post_id):
        global tag_filter

        info = self.scrape_post_info(post_id)
        tags = []
        for kind in ("artist", "copyright"):
            tags += sorted(info["tags"][kind])
        tags = tag_filter.filter(tags)
        return tags

def rename_file_in_dir(dirpath, filename):
    global args
    global bare_re
    global api

    fmt_found = "\033[38;5;10m%s\033[m"
    fmt_notfound = "\033[38;5;9m%s\033[m"

    m = bare_re.match(filename)
    if m:
        old_path = os.path.join(dirpath, filename)
        print(old_path, end=" ", flush=True)
        file_md5 = m.group(1)
        file_ext = m.group(2)
        posts = list(api.find_posts("md5:%s" % file_md5))
        if posts:
            post_id = posts[0]["id"]
            tags = api.get_tags_by_id(post_id)
            tags.append("g%s" % post_id)
            tags = list(uniq(tags))
            tags.append(file_md5 + file_ext)
            new_filename = " ".join(tags)
            new_path = os.path.join(dirpath, new_filename)
            print("=>", fmt_found % new_filename)
            if not args.dry_run:
                os.rename(old_path, new_path)
        else:
            print("=>", fmt_notfound % "[not found]")

parser = argparse.ArgumentParser()
parser.add_argument("path", nargs=argparse.ZERO_OR_MORE)
parser.add_argument("-n", "--dry-run", action="store_true", help="Do nothing.")
args = parser.parse_args()

bare_re = re.compile(r'^([0-9a-f]{32})(\.\w+)$')
api = GelbooruApi()
tag_filter = TagFilter.load_config("gelbooru-tags.conf")

for arg in args.path or ["."]:
    if not os.path.exists(arg):
        Core.err("path %r does not exist" % arg)
    if os.path.isdir(arg):
        for dirpath, dirnames, filenames in os.walk(arg):
            for filename in filenames:
                rename_file_in_dir(dirpath, filename)
    else:
        dirpath, filename = os.path.split(arg)
        rename_file_in_dir(dirpath, filename)

Core.exit()
