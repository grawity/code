#!/usr/bin/env perl
# getnetrc -- query passwords from ~/.netrc
use v5.8;
use warnings;
use strict;
use Getopt::Long qw(:config gnu_getopt no_ignore_case);
use Net::Netrc;

$::arg0 = (split m!/!, $0)[-1];

sub warnx {
	my ($msg) = @_;
	warn "$::arg0: $msg\n";
}

sub errx {
	my ($exit, $msg) = @_;
	warnx($msg);
	exit $exit;
}

my $format		= "%l:%p";
my $format_nonewline	= 0;
my $format_url_encode	= 0;
my $service		= undef;
my $service_required	= 0;
my $no_default		= 0;

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-dnsu] [-f format] [service/]machine [login]",
	"",
	#12345678........12345678........12345678........12345678........12345678........
	"Options:",
	"  -d            disable fallback to 'default' entry",
	"  -n            do not print final newline",
	"  -f format     format the output as specified (default is %l:%p)",
	"  -s            if 'service/machine' was given, disable fallback to 'machine'",
	"  -u            URL-encode each item separately",
	"",
	"Format strings:",
	"  %m, %h        result machine (hostname)",
	"  %l, %u        result login (username)",
	"  %p            result password",
	"  %a            result account",
	"  %M            query machine",
	"  %S            query service",
	"  %%, %n, %0    percent sign, newline, null byte",
	"",
	"The .netrc file format is described in the manual page of ftp(1), with",
	"the exception of 'service/machine' syntax which is a custom extension.";
}

sub lookup {
	my ($machines, $login) = @_;
	my $fallback;
	for my $machine (@$machines) {
		my $en = Net::Netrc->lookup($machine, $login);
		if (defined $en) {
			if (defined $en->{machine}) {
				return $en;
			} elsif (!$no_default) {
				$fallback //= $en;
			}
		}
	}
	return $fallback;
}

sub _fmt_expn {
	my ($data, $raw, $key) = @_;
	if ($key eq "%") {
		return $key;
	} elsif (exists $data->{$key}) {
		return $data->{$key} // "";
	} else {
		warnx("unknown format character '$raw'");
		return "$raw";
	}
}

sub fmt {
	my ($str, $data) = @_;
	$str =~ s!%(?:([^{])|\{(.+?)\})!_fmt_expn($data, $&, $1 // $2)!ge;
	return $str;
}

sub uri_encode {
	my ($str) = @_;
	if (defined $str) {
		$str =~ s/([^A-Za-z0-9.!~*'()-])/sprintf("%%%02X", ord($1))/seg;
	}
	return $str;
}

# parse command line

GetOptions(
	"help"			=> sub { usage(); exit; },
	"f|format=s"		=> \$format,
	"n|no-newline"		=> \$format_nonewline,
	"u|urlencode"		=> \$format_url_encode,
	"s|service-required"	=> \$service_required,
	"d|no-default"		=> \$no_default,
) or exit 2;

my ($machine, $login) = @ARGV;

unless (defined($machine) && length($machine)) {
	errx(2, "missing machine name");
}

if ($machine =~ m{^([^/]+)[@/](.+)$}) {
	$service = $1;
	$machine = $2;
}

# look up entry

my @machines;
if ($service) {
	push @machines, $service.'/'.$machine;
	push @machines, $service.'@'.$machine;
}
if (!$service || !$service_required) {
	push @machines, $machine;
}

my $entry = lookup(\@machines, $login) || exit 1;

# format results

if (!$format_nonewline) {
	$format .= "%n";
}

my %output = (
	%$entry,
	a => $entry->{account},
	h => $entry->{machine},
	l => $entry->{login},
	m => $entry->{machine},
	p => $entry->{password},
	u => $entry->{login},
	M => $machine,
	S => $service,
);
if ($format_url_encode) {
	$output{$_} = uri_encode($output{$_}) for keys %output;
}
@output{"n", "0"} = ("\n", "\0");

print fmt($format, \%output);
