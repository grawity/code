#!/usr/bin/env bash
# sshkeyupdate -- download ~/.ssh/authorized_keys from central URL

readonly unix_user="grawity"
readonly src_url="http://nullroute.lt/~grawity/files/authorized_keys.txt"
readonly signer_key="$HOME/bin/.pubkey.pgp"
readonly signer_fpr="2357E10CEF4F7ED27E233AD5D24F6CB2C1B52632"

PATH="$HOME/bin:$PATH"

. lib.bash || exit
. ~/bin/lib/libfilterfile.bash || exit
. ~/bin/lib/libhttpfetch.bash || exit

usage() {
	echo "Usage: $progname [-f] [-q] [-i]"
	echo ""
	echo_opt "-f"		"proceed on username mismatch"
	echo_opt "-q"		"quietly exit if update is not to be done"
	echo_opt "-i"		"import embedded signing key"
}

filter_keys() {
	filter_file 'match_hostname'
}

fetch() {
	local url=$1 out=$2
	local maxtries=3 delay=3 attempt=1
	while true; do
		debug "fetching $url (try #$attempt)"
		if http_fetch "$url" "$out"; then
			return 0
		elif (( $? == 99 )); then
			break
		fi
		rm -f "$out"
		if (( attempt++ >= maxtries )); then
			break
		fi
		sleep $delay
		(( delay *= 2 ))
	done
	return 1
}

verify_gpg() {
	local input=$1 output=$2 status= errors=0

	if ! have gpg; then
		vmsg "gpg is not installed" >&2
		return 2
	fi
	if ! [[ -d ~/.gnupg ]]; then
		vmsg "cannot validate using gpg; ~/.gnupg is not initialized" >&2
		return 2
	fi
	if ! gpg -k "$signer_fpr" > /dev/null; then
		vmsg "cannot validate using gpg; key $signer_fpr not in keyring" >&2
		return 2
	fi

	if ! status=$(gpg --batch --yes --status-fd 1 --output "$output" \
	                 --trust-model pgp --decrypt "$input" 2> /dev/null); then
		vmsg "unknown gpg error" >&2
		echo "$status" >&2
		return 1
	fi
	if ! grep -Eqs "^\\[GNUPG:\\] VALIDSIG $signer_fpr " <<< "$status"; then
		vmsg "validation failed or signer mismatch" >&2
		echo "$status" >&2
		return 1
	fi

	return 0
}

verify_gpgv() {
	local input=$1 output=$2 status=

	if ! have gpgv; then
		vmsg "gpgv is not installed" >&2
		return 2
	fi

	if ! status=$(gpgv --status-fd 1 --keyring "$signer_key" --output "$output" \
			"$input" 2>/dev/null); then
		vmsg "validation failed" >&2
		return 1
	fi
	if ! grep -Eqs "^\\[GNUPG:\\] VALIDSIG $signer_fpr " <<< "$status"; then
		vmsg "validation failed or signer mismatch" >&2
		echo "$status" >&2
		return 1
	fi

	return 0
}

verify_sop() {
	local input=$1 output=$2 sop=

	if [ "$SOP" ]; then
		sop=$SOP
	elif have sqop; then
		sop=sqop
	elif have rsop; then
		sop=rsop
	elif have gosop; then
		sop=gosop
	else
		vmsg "sop is not installed" >&2
		return 2
	fi

	local status="$workdir/verify.out"

	if ! $sop inline-verify --verifications-out "$status" \
			"$signer_key" < "$input" > "$output"; then
		vmsg "validation failed" >&2
		return 1
	fi
	if ! [ "$(awk '{print toupper($2)}' < "$status")" = "$signer_fpr" ]; then
		vmsg "signer mismatch" >&2
		cat "$status" >&2
		return 1
	fi
	if ! [ "$(awk '{print toupper($3)}' < "$status")" = "$signer_fpr" ]; then
		vmsg "signer mismatch" >&2
		cat "$status" >&2
		return 1
	fi

	return 0
}

verify() {
	if [ "$SOP" = gpgv ]; then
		verify_gpgv "$@"
	elif [ "$SOP" ] || have sqop || have rsop || have gosop; then
		verify_sop "$@"
	else
		verify_gpg "$@"
	fi
}

umask 077

opt_testfilter=0
opt_force=0
opt_importkey=0
opt_quiet=0
dst_file=~/.ssh/authorized_keys

while getopts :Ffiq OPT; do
	case $OPT in
	F) opt_testfilter=1;;
	f) opt_force=1;;
	i) opt_importkey=1;;
	q) opt_quiet=1;;
	*) lib:die_getopts;;
	esac
done; shift $[OPTIND-1]

if (( $# )); then
	vdie "excess arguments"
fi

if (( opt_testfilter )); then
	if [[ -t 0 ]]; then
		vdie "filter test mode requires file input"
	fi
	if [[ -t 1 ]]; then
		export FILTERDEBUG=1
		exec >/dev/null
	fi
	filter_keys
	exit
fi

if [[ -e "$dst_file.noupdate" ]] || grep -qs "^# *NOUPDATE" "$dst_file"; then
	if (( opt_force )); then
		true
	elif (( !opt_quiet )); then
		vdie "\"no update\" marker found, exiting"
	else
		exit 0
	fi
fi

if [[ "$LOGNAME" != "$unix_user" ]]; then
	if [[ -e "$dst_file.optin" ]]; then
		true
	elif (( opt_force )); then
		vmsg "username mismatch, creating opt-in marker"
		echo "$LOGNAME on $(date)" > "$dst_file.optin"
	elif (( !opt_quiet )); then
		vdie "username mismatch, this program isn't for you"
	else
		exit 0
	fi
fi

# ensure key exists in keyring

if (( opt_importkey )); then
	vmsg "importing embedded owner key into GnuPG keyring"
	gpg --import "$signer_key"
	echo "$signer_fpr:6:" | gpg --import-ownertrust
fi

# download new pubkeys

workdir=$(mktemp -d /tmp/sshkeyupdate.XXXXXX) || exit
tmp_signed="$workdir/signed.txt"
tmp_plain="$workdir/output.txt"

mkdir -p "${dst_file%/*}"

if ! fetch "$src_url" "$tmp_signed"; then
	rm -f "$tmp_signed"
	vdie "fetch of $src_url failed"
elif ! test -s "$tmp_signed"; then
	rm -f "$tmp_signed"
	vdie "empty file fetched from $src_url"
fi

if ! verify "$tmp_signed" "$tmp_plain"; then
	if (( $? == 2 )); then
		rm -f "$tmp_plain"
		vdie "verification of $tmp_signed could not be performed"
	else
		rm -f "$tmp_plain"
		vdie "verification of $tmp_signed failed"
	fi
fi

local_file="$dst_file.local"

{
	echo "# updated: at $(date +"%Y-%m-%d %H:%M:%S %z")"
	echo "# updated: from $src_url"
	cat "$tmp_plain" | tr -d '\r'
	if [[ -s $local_file ]]; then
		echo "# updated: from $local_file"
		cat "$local_file"
	fi
	echo "# updated: end"
} | filter_keys > "$dst_file"

rm -rf "${workdir?}"

if [[ -t 1 ]]; then
	num=$(grep -c '^[^#]' "$dst_file")
	vmsg "imported $num keys"
fi
