#!/usr/bin/env python3
import argparse
from nullroute.core import Core
from nullroute.file import digest_files, get_file_attr, set_file_attrs
from nullroute.misc import filter_filename
from nullroute.scrape import Scraper
import os
from pprint import pprint
import re
from requests.exceptions import HTTPError
import sys

class ScrapeError(Exception):
    pass

class ForeignFilenameError(ValueError):
    pass

class DeviantArtScraper(Scraper):
    _fn_re = re.compile(r"^(?:[a-f0-9]{32}|.*[-_]by[-_].*)-(\w+)\.\w+$")
    _upd_fn_re = re.compile(r"^.+ \((d\w+)\)\.\w+$")

    def get_favid_from_filename(self, filename, for_update=False):
        m = (self._upd_fn_re if for_update else self._fn_re).match(filename)
        if not m:
            raise ForeignFilenameError("filename %r did not match regex" % filename)
        return m.group(1)

    def get_favurl_by_favid(self, favid):
        if not re.match(r"^\w+$", favid):
            raise ValueError("favid %r did not match regex" % favid)
        return "http://fav.me/%s" % favid

    def get_oembed_info_by_favid(self, favid):
        favurl = self.get_favurl_by_favid(favid)
        r = self.get("https://backend.deviantart.com/oembed",
                     params={"url": favurl, "format": "json"})
        return r.json()

    def get_pageurl_by_favid(self, favid):
        favurl = self.get_favurl_by_favid(favid)
        Core.debug("fetching %r" % favurl)
        r = self.ua.head(favurl,
                         allow_redirects=False,
                         # server returns 403 if A-E is missing
                         # requests adds its own, but let's be 100% sure
                         headers={"Accept-Encoding": "identity"})
        r.raise_for_status()
        if r.status_code != 301:
            raise ScrapeError("unexpected status %r from %r" % (r, favurl))
        return r.headers["location"]

def filter_title(title):
    title = title.replace("[+Video]", "")
    title = re.sub(r"\s+", " ", title)
    return title.strip()

def files_eq(a, b):
    astat = os.stat(a)
    bstat = os.stat(b)
    if astat.st_size != bstat.st_size:
        return False
    digests = digest_files([a, b])
    if digests[a] != digests[b]:
        return False
    return True

def rename_file_in_dir(old_dir, old_name, args, foreign_warn=True):
    fmt_found = "\033[38;5;10m%s\033[m"
    fmt_notfound = "\033[38;5;9m%s\033[m"
    fmt_noop = "\033[38;5;8m%s\033[m"

    try:
        favid = da.get_favid_from_filename(old_name,
                                          for_update=(args.update or args.force_update))
    except ForeignFilenameError:
        (Core.warn if foreign_warn else Core.debug)("could not find favid in filename %r", filename)
        return

    old_path = os.path.join(old_dir, old_name)
    print(old_path, end=" ", flush=True)

    info = {}
    referer = None

    # obtain metadata

    if args.update and not args.force_update:
        info = {
            "imagetype": old_name.split(".")[-1],
            "author_name": get_file_attr(old_path, "dublincore.creator"),
            "title": get_file_attr(old_path, "dublincore.title"),
        }
        referer = get_file_attr(old_path, "xdg.referrer.url")

    if not (info.get("author_name") and info.get("title")):
        try:
            info = da.get_oembed_info_by_favid(favid)
        except HTTPError as e:
            print(fmt_notfound % "failed")
            Core.err(str(e))
            return

    # apply the new name

    info["_favid"] = favid
    info["_title"] = filter_title(info["title"])
    if Core._in_debug_mode():
        pass
        #pprint(info)

    if args.inverse:
        new_name = "%(_title)s by %(author_name)s (%(_favid)s).%(imagetype)s" % info
    elif args.no_title:
        new_name = "%(author_name)s (%(_favid)s).%(imagetype)s" % info
    else:
        new_name = "%(author_name)s “%(_title)s” (%(_favid)s).%(imagetype)s" % info

    new_name = filter_filename(new_name, allow_space=True)
    new_path = os.path.join(old_dir, new_name)

    if old_path == new_path:
        Core.debug("new file %r is the same as old; doing nothing", new_path)
        print("=>", fmt_noop % "(no change)")
        return
    elif os.path.exists(new_path):
        if files_eq(old_path, new_path):
            Core.notice("new file %r already exists and is a duplicate; overwriting", new_path)
        else:
            Core.err("new file %r already exists and is different; skipping", new_path)
            print("=>", fmt_notfound % "(conflict)")
            return

    print("=>", fmt_found % new_name)
    if not args.dry_run:
        os.rename(old_path, new_path)

    # apply xattrs

    if not (referer and ".deviantart.com/" in referer):
        referer = da.get_pageurl_by_favid(favid)

    attrs = {
        "dublincore.title": info["title"],
        "dublincore.creator": info["author_name"],
        "xdg.referrer.url": referer,
    }
    if not args.dry_run:
        set_file_attrs(new_path, attrs)

parser = argparse.ArgumentParser()
parser.add_argument("path", nargs=argparse.ZERO_OR_MORE)
parser.add_argument("-n", "--dry-run", action="store_true", help="Do nothing.")
parser.add_argument("-I", "--inverse", action="store_true", help="Use '<title> by <artist>' filenames.")
parser.add_argument("-u", "--update", action="store_true", help="Match and update existing filenames only.")
parser.add_argument("-U", "--force-update", action="store_true", help="Update from the net (ignore existing attrs).")
parser.add_argument("--no-title", action="store_true", help="Do not add artwork title to filename.")
args = parser.parse_args()

if sum(map(int, [args.inverse, args.no_title])) > 1:
    Core.die("mutually exclusive options specified")

da = DeviantArtScraper()

for arg in args.path or ["."]:
    if os.path.isdir(arg):
        for dirpath, dirnames, filenames in os.walk(arg):
            for filename in filenames:
                rename_file_in_dir(dirpath, filename, args, foreign_warn=False)
    else:
        dirpath, filename = os.path.split(arg)
        rename_file_in_dir(dirpath, filename, args, foreign_warn=True)
