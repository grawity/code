#!/usr/bin/env perl
use warnings;
use strict;
use Data::Dumper;
use File::stat;
use Nullroute::Lib;

sub _sh_esc { map {/[ $()*?<>;=]/ ? "'$_'" : $_} @_; }

sub ffprobe {
	my ($file) = @_;
	my %codecs;
	my ($_idx, $_type, $_codec);
	open(my $fh, "-|") || do {
		open(*STDERR, ">", "/dev/null");
		exec {"ffprobe"}
			("ffprobe",
			-print_format => "compact",
			-show_format => (),
			-show_streams => (),
			$file);
	};
	while (<$fh>) {
		chomp;
		my ($type, @rest) = split(/\|/, $_);
		my %rest = map {split(/=/, $_, 2)} @rest;
		if ($type eq "stream") {
			my $c_type = $rest{codec_type};
			my $c_name = $rest{codec_name};
			my $c_rate = $rest{sample_rate};
			if ($c_type eq "audio" && $c_rate) {
				$c_name .= "_".$c_rate;
			}
			$codecs{$c_type} = $c_name;
		}
		elsif ($type eq "format") {
			$codecs{container} = $rest{format_name};
		}
	}
	close($fh);
	return %codecs;
}

# parse args

my @PREF = qw(mp4 mkv rm);

my %CODECS = (
	# audio
	aac => "mp4",
	cook => "rm",
	mp2 => "mp4",
	mp3 => "mp4",
	mp3_11025 => "mkv",
	wmav2 => "wmv,mkv",

	# video
	h264 => "mp4",
	rv20 => "rm",
	rv40 => "rm",
	vp6f => "mkv",
	wmv3 => "wmv,mkv",
);

my $infile = undef;
my $inbase = undef;
my $outext = undef;
my $outfile = undef;
my @ff_meta = ();
my @ff_args = ("ffmpeg",
		-hide_banner => ());
my %tag_args = ();
my @tag_args = ("mp4tags");

for (@ARGV) {
	if (/^(year|date)=(.*)/) {
		push @ff_meta, "date=$2";
	}
	elsif (/^(name|song|title)=(.*)/) {
		push @ff_meta, "title=$2";
	}
	elsif (/^season=(.*)/) {
		push @ff_meta, "season_number=$1";
	}
	elsif (/^episode=(.*)/) {
		push @ff_meta, "episode_id=$1";
	}
	elsif (/^(kind|type)=(.*)/) {
		$tag_args{-type} = $1;
	}
	elsif (/.=/) {
		push @ff_meta, $_;
	}
	elsif (/^-/) {
		_die("unknown option '$_'", 2);
	}
	elsif (-f $_) {
		$infile = $_;
	}
	else {
		_die("unrecognized arg '$_'", 2);
	}
}

if (!$infile) {
	_die("missing input file", 2);
} elsif (!-f $infile) {
	_die("input file \"$infile\" does not exist");
} else {
	_info("input: $infile");
	push @ff_args, (-i => $infile);
}

push @ff_args, map {-metadata => $_} @ff_meta;

$inbase = $infile;
$inbase =~ s/\.[^.]+?$//;

# detect codecs

my $container = "mp4";
my $acodec = "copy";
my $vcodec = "copy";

my $instat = stat($infile);
my %incodecs = ffprobe($infile);

my $audio_can_mp4 = 1;
my $video_can_mp4 = 1;

my $in_acodec = $incodecs{audio};
my $in_vcodec = $incodecs{video};

print Dumper(\%incodecs);
#exit;

# determine output file

$outext = $container;
$outfile = $inbase.".".$outext;
if ($infile eq $outfile) {
	_die("input and output are the same file");
}

# run ffmpeg

push @ff_args, $outfile;

print Dumper(\@ff_args);

_info("running ".join(" ", _sh_esc(@ff_args)));

#system {"ffmpeg"} @ff_args;

# run mp4tags

if (%tag_args) {
	push @tag_args, $outfile, %tag_args;

	print Dumper(\@tag_args);

	_info("running ".join(" ", _sh_esc(@tag_args)));

	system {"mp4tags"} @tag_args;
}

# clean up

if (-e $outfile) {
	system "mp4info", $outfile;
	system "trash", $infile;
	utime($instat->atime, $instat->mtime, $outfile);
} else {
	_die("conversion failed (output file missing)");
}
