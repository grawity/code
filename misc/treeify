#!/usr/bin/env perl
# treeify - display a list of files as a tree
# (c) 2013-2016 Mantas Mikulėnas <grawity@gmail.com>
# Released under the MIT License (dist/LICENSE.mit)
use v5.10;
use warnings;
use strict;
use Getopt::Long qw(:config bundling no_ignore_case);
use File::Spec;
use constant {
	true => 1,
	false => 0,
};

my %GRAPH = (
	# tree
	s_mid => "│",
	i_mid => "├",
	i_end => "└",
	s_end => " ",
	# tree branch extension/padding
	i_br => "─",
	s_br => " ",
	# sideways branch
	br_cont => "┬",
	br_leaf => "─",
	# ghost nodes
	ghost_pre => "[",
	ghost_suf => "]",
	# colors
	c_tree => "",
	c_ghost => "",
	c_reset => "",
);

my %opt = (
	style => "normal",
	color => "auto",
	fakeroot => undef,
	maxdepth => 0,
	noghosts => 0,
	path => undef,
	printfull => 0,
	reverse => 0,
	sep => "/",
);

sub color {
	my ($color, $str) = @_;
	if ($color && $GRAPH{$color}) {
		return $GRAPH{$color}.$str.$GRAPH{c_reset};
	} else {
		return $str;
	}
}

sub canonpath {
	my $path = shift;
	if ($opt{sep} ne "/") {
		return $path;
	} elsif ($path =~ m|^(\./)|) {
		return $1 . File::Spec->canonpath($path);
	} else {
		return File::Spec->canonpath($path);
	}
}

sub split_path {
	my $path = canonpath(shift);
	my @path;
	for (split(/\Q$opt{sep}\E+/, $path)) {
		if ($_ eq "")		{ push @path, $opt{sep}; }
		elsif (!@path)		{ push @path, $_; }
		elsif ($_ eq ".")	{ next; }
		elsif ($_ eq "..")	{ pop @path; }
		else			{ push @path, $_; }
	}
	if ($opt{reverse}) {
		@path = reverse @path;
	}
	return @path ? @path : $opt{sep};
}

sub walk {
	my ($branch, $path) = @_;
	for (split_path($path)) {
		$branch = $branch->{$_} //= {};
	}
	return $branch;
}

sub crawl {
	my ($branch, $child) = @_;
	while ($branch->{$child}) {
		$branch = $branch->{$child};
	}
	return $branch;
}

sub deepcount {
	my ($branch) = @_;
	my $count = 0;
	for (values %$branch) {
		$count += 1 + deepcount($_);
	}
	return $count;
}

sub show {
	my ($branch, $seen, $depth, $graph, $root) = @_;

	$depth //= 0;
	$graph //= [""];
	$root //= "";

	my $shallow = $opt{maxdepth} && $depth >= $opt{maxdepth};
	my $frdepth = defined($opt{fakeroot}) ? (2 - $opt{printfull}) : 0;

	# Child tree indent level
	my $sub_indent = 1;
	# Rightwards branch length
	my $branch_pad = 1;
	# Whether child trees descend from the branch
	my $sideways = false;
	# Space between branch and label (currently sideways-only)
	my $name_pad = 0;

	if ($opt{style} eq "compact") {
		$sub_indent = 0;
	} elsif ($opt{style} eq "vcompact") {
		$sub_indent = 0;
		$branch_pad = 0;
	} elsif ($opt{style} eq "sideways") {
		$sideways = true;
		$sub_indent = 0; # required
		$name_pad = 1; # adjustable
	} elsif ($opt{style} eq "sideways-compact") {
		$sideways = true;
		$sub_indent = 0;
		$name_pad = 0;
	} elsif ($opt{style} eq "sideways-vcompact") {
		$sideways = true;
		$sub_indent = 0;
		$branch_pad = 0;
		$name_pad = 0;
	} else {
		die "error: Unknown style '$opt{style}'\n";
	}

	my @keys = keys %$branch;
	if (eval {require Sort::Naturally}) {
		@keys = Sort::Naturally::nsort(@keys);
	} else {
		@keys = sort @keys;
	}
	while (@keys) {
		my $name = shift @keys;
		my $node = $branch->{$name};
		my $exists = $opt{noghosts} || exists($seen->{$node});

		my $children = keys %$node;
		if ($shallow && $children) {
			$children = deepcount($node);
		}

		if ($opt{printfull}) {
			# Display full path of the current node
			if ($root eq $opt{sep}) {
				$name = $opt{reverse}
					? $name.$root
					: $root.$name;
			} elsif ($depth > $frdepth) {
				$name = $opt{reverse}
					? $name.$opt{sep}.$root
					: $root.$opt{sep}.$name;
			}
		}

		if ($depth > 0) {
			$graph->[$depth] = (@keys ? $GRAPH{i_mid} : $GRAPH{i_end}).($GRAPH{i_br} x $branch_pad);
		} elsif ($sideways) {
			# For sideways graphs (where subtrees descend directly
			# from the branch, rather than from the name), even the
			# root has a branch, therefore needs padding.
			$graph->[$depth] = ($GRAPH{i_br} x $branch_pad);
		}

		my $tree_str = join(" " x $sub_indent, @$graph);
		if ($sideways) {
			$tree_str .= ($children ? $GRAPH{br_cont} : $GRAPH{br_leaf});
		}

		if ($depth > 0) {
			$graph->[$depth] = (@keys ? $GRAPH{s_mid} : $GRAPH{s_end}).($GRAPH{s_br} x $branch_pad);
		} elsif ($sideways) {
			$graph->[$depth] = ($GRAPH{s_br} x $branch_pad);
		}

		my $line_str;
		$line_str .= color("c_tree", $tree_str);
		$line_str .= " " x $name_pad;
		if ($exists) {
			$line_str .= $name;
		} else {
			$line_str .= color("c_tree", $GRAPH{ghost_pre});
			$line_str .= color("c_ghost", $name);
			$line_str .= color("c_tree", $GRAPH{ghost_suf});
		}
		if ($shallow && $children) {
			$line_str .= color("c_tree", " ($children)");
		}
		print "$line_str\n";

		show($node, $seen, $depth+1, $graph, $name) if !$shallow;
	}

	pop @$graph;
}

sub usage {
	print "$_\n" for
	"Usage: treeify [-d DEPTH] [-f] [-g] [-r ROOT] [-R] [-s SEP] [-y STYLE] [PATH]",
	"",                           #
	"  -d, --max-depth DEPTH      Limit tree depth",
	"  -f, --full-names           Show full names of branches and leaves",
	"  -g, --no-ghosts            Do not highlight 'ghost' branches",
	"  -r, --fake-root PATH       Prefix with a fake root container",
	"  -R, --reverse              Process paths in reverse (for DNS domains)",
	"  -s, --separator SEP        Split paths at SEP instead of '/'",
	"  -y, --style STYLE          Change appearance (normal, compact, sideways)",
	"  PATH                       Only show items under given branch";
}

GetOptions(
	"help" => sub { usage(); exit; },
	"C|color=s" => \$opt{color},
	"d|max-depth=i" => \$opt{maxdepth},
	"f|full-names+" => \$opt{printfull},
	"g|no-ghosts" => \$opt{noghosts},
	"r|fake-root=s" => \$opt{fakeroot},
	"R|reverse" => \$opt{reverse},
	"s|separator=s" => \$opt{sep},
	"y|style=s" => \$opt{style},
	map {
		$_ => sub { $opt{maxdepth} = ($opt{maxdepth} * 10) + int($_[0]) },
	} 0..9,
) or exit(2);

for (@ARGV) {
	if (/^@(.+)$/) {
		$opt{fakeroot} = $1;
	} else {
		$opt{path} = canonpath($_);
	}
}

# decide on output features

if ($opt{color} eq "auto") {
	my $term = (-t 1) ? $ENV{TERM} : undef;
	if (!$term || $term eq "dumb") {
		$opt{color} = "off";
	} elsif ($term =~ /-256color$/ || $term =~ /^(xterm|tmux)/) {
		$opt{color} = "256";
	} else {
		$opt{color} = "16";
	}
}

if ($opt{color} eq "256") {
	$GRAPH{c_tree} = "\e[38;5;59m";
	$GRAPH{c_ghost} = "\e[38;5;109m";
	$GRAPH{c_reset} = "\e[m";
} elsif ($opt{color} !~ /^(no|off)$/) {
	$GRAPH{c_tree} = "\e[36m";
	$GRAPH{c_ghost} = "\e[36m";
	$GRAPH{c_reset} = "\e[m";
}

# parse input

my $node;
my $tree = {};
my $seen = {};

# Parse input
while (<STDIN>) {
	chomp;
	$seen->{walk($tree, $_)} = 1;
}

# Descend into specified path
if ($opt{path}) {
	# Discard any "./" prefix, so that 'find | treeify foo' would Do What
	# You Mean and correctly descend into "./foo".
	$tree = crawl($tree, ".");
	$tree = {$opt{path} => walk($tree, $opt{path})};
}

# Prefix with fake root node
if ($opt{fakeroot}) {
	# If the input starts at "/", we want to throw that away when showing a
	# custom root prefix.
	$tree = crawl($tree, "/");
	$tree = {$opt{fakeroot} => $tree};
}

show($tree, $seen);
